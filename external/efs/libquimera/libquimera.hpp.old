#ifndef __LIBQUIMERA__
#define __LIBQUIMERA__

#include <cstdlib>
#include "../math/gamma.hpp"

class p_ERIbuffer;
class p_Qalgorithm;
class p_Quimera;
class cacheline;
class ShellPairPrototype;
class ShellPair;
class ERIgeometryV;



namespace LibQuimera __attribute__ ((visibility ("default"))) {
    class Qalgorithm;

    //ERI computational quantum
    struct ERITile {
        UI32 ap12[DOUBLES_PER_CACHE_LINE];
        UI32 ap34[DOUBLES_PER_CACHE_LINE];

        UI16 nKab;
        UI16 nKcd;

        // these are the offsets within the atom pair block for Sparse tensors;
        // they are the same  for all integrals involving the same elemental GTO quadruplet,
        // but storing them makes it possible to decouple the OC and DL parts of the computation
        // later on, so that all transformations/contraction involving same angular momenta can be
        // processed in a batch; also, the structure is already >64 bytes, so it doesnt harm performance
        UI32 offAB;
        UI32 offCD;
        UI32 offAC;
        UI32 offAD;
        UI32 offBC;
        UI32 offBD;

        UI8 used;      //number of used elements (0-DOUBLES_PER_CACHE_LINE)
        UI8 distance;  //distance block

        UI8 align[34]; // maybe i'll find something more useful later
    } __attribute__((aligned(128)));
    //131 + 2bytes

    class ERIbuffer {
        friend class Qalgorithm;

      private:
        p_ERIbuffer * pERIbuffer; //private implementation

      public:
        ERIbuffer();
        ~ERIbuffer();
        size_t SetBuffers(cacheline * mem, const ShellPairPrototype & ABp, const ShellPairPrototype & CDp,  const Qalgorithm & routine);
    };

    class Qalgorithm {
        friend class ::p_Quimera;
        friend class ERIbuffer;

      private:
        p_Qalgorithm * pQalgorithm; //private implementation

      public:
        Qalgorithm();
        ~Qalgorithm();

        UI32 GetNKernels() const;

        //execute
        void K4(const ShellPair * ABs, const ShellPair * CDs, const ERIgeometryV & vars8, const ERITile & ET, const ShellPairPrototype & ABp, const ShellPairPrototype & CDp, cacheline * uv_m_st8, ERIbuffer & buffer, bool UseCase = false);
        void K4(const ShellPairPrototype & ABp, const ShellPairPrototype & CDp, double * uv_m_st, ERIbuffer & buffer, bool UseCase = false);

        void MIRROR(const cacheline *   mem, const ERIgeometryV & vars8, cacheline * ERI8, ERIbuffer & buffer);
        void MIRROR(const double *  uv_m_st, double * W, ERIbuffer & buffer);
    };

    class Quimera {
      private:
        p_Quimera * pQuimera; //private implementation

      public:
        Quimera();
        ~Quimera();

        const Qalgorithm * SelectAlgorithm (GEOM geometry, UI8  La, UI8  Lb, UI8  Lc, UI8  Ld, bool isGC, bool isLR, bool isCDR = false);

        void ListNeeded     (GEOM geometry, UI8  La, UI8  Lb, UI8  Lc, UI8  Ld, bool isGC, bool isLR, bool isCDR = false);
        void GenerateNeeded (bool overwrite);

        void Statistics() const;
    };

    Quimera Q;

    GammaFunction IncompleteGamma;
    GammaFunction IncompleteGammas[4*LMAX+3]; //+2 for derivatives

    int InitLibQuimera();

}

#endif
