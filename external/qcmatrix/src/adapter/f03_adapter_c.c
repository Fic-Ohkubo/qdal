/*
   QcMatrix: an abstract matrix library
   Copyright 2012-2015 Bin Gao
   
   QcMatrix is free software: you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.
   
   QcMatrix is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU Lesser General Public License for more details.
   
   You should have received a copy of the GNU Lesser General Public License
   along with QcMatrix. If not, see <http://www.gnu.org/licenses/>.
   
   This file implements the functions in adapter/mat_adapter.h by calling
   src/adapter/f03_adapter_f.F90.
   
   2014-03-11, Bin Gao:
   * generated by tools/qcmatrix_fortran.py
*/

#include "adapter/mat_adapter.h"

/* declaration of Fortran 2003 subroutines */
extern QVoid Mat_Ptr_Create(QVoid **A);
extern QVoid Mat_Ptr_Destroy(QVoid **A);
#if defined(ADAPTER_BLOCK_CMPLX) || defined(ADAPTER_BLOCK_REAL)
extern QVoid Mat_Ptr_BlockCreate(QVoid **A, const QInt dim_block);
#endif
extern QVoid Mat_Ptr_SetSymType(QVoid **A, const QInt sym_type);
#if defined(ADAPTER_BLOCK_CMPLX)
extern QVoid Mat_Ptr_SetDataType(QVoid **A,
                                 const QInt num_blocks,
                                 const QInt *idx_block_row,
                                 const QInt *idx_block_col,
                                 const QInt *data_type);
#elif defined(ADAPTER_BLOCK_REAL)
extern QVoid Mat_Ptr_SetNonZeroBlocks(QVoid **A,
                                      const QInt num_blocks,
                                      const QInt *idx_block_row,
                                      const QInt *idx_block_col);
#elif defined(ADAPTER_CMPLX_MAT)
extern QVoid Mat_Ptr_SetDataType(QVoid **A, const QInt data_type);
#endif
extern QVoid Mat_Ptr_SetDimMat(QVoid **A, const QInt num_row, const QInt num_col);
#if defined(QCMATRIX_STORAGE_MODE)
extern QVoid Mat_Ptr_SetStorageMode(QVoid **A, const QInt storage_mode);
#endif
extern QVoid Mat_Ptr_Assemble(QVoid **A);
#if defined(ADAPTER_BLOCK_CMPLX) || defined(ADAPTER_BLOCK_REAL)
extern QVoid Mat_Ptr_GetDimBlock(QVoid **A, QInt *dim_block);
#endif
extern QVoid Mat_Ptr_GetSymType(QVoid **A, QInt *sym_type);
#if defined(ADAPTER_BLOCK_CMPLX)
extern QVoid Mat_Ptr_GetDataType(QVoid **A,
                                 const QInt num_blocks,
                                 const QInt *idx_block_row,
                                 const QInt *idx_block_col,
                                 QInt *data_type);
#elif defined(ADAPTER_BLOCK_REAL)
extern QVoid Mat_Ptr_GetNonZeroBlocks(QVoid **A,
                                      const QInt num_blocks,
                                      const QInt *idx_block_row,
                                      const QInt *idx_block_col,
                                      QInt *is_non_zero);
#elif defined(ADAPTER_CMPLX_MAT)
extern QVoid Mat_Ptr_GetDataType(QVoid **A, QInt *data_type);
#endif
extern QVoid Mat_Ptr_GetDimMat(QVoid **A, QInt *num_row, QInt *num_col);
#if defined(QCMATRIX_STORAGE_MODE)
extern QVoid Mat_Ptr_GetStorageMode(QVoid **A, QInt *storage_mode);
#endif
extern QVoid Mat_Ptr_IsAssembled(QVoid **A, QInt *assembled);
#if defined(ADAPTER_BLOCK_CMPLX)
extern QVoid Mat_Ptr_SetRealValues(QVoid **A,
                                   const QInt idx_block_row,
                                   const QInt idx_block_col,
                                   const QInt idx_first_row,
                                   const QInt num_row_set,
                                   const QInt idx_first_col,
                                   const QInt num_col_set,
                                   const QReal *values_real);
extern QVoid Mat_Ptr_SetImagValues(QVoid **A,
                                   const QInt idx_block_row,
                                   const QInt idx_block_col,
                                   const QInt idx_first_row,
                                   const QInt num_row_set,
                                   const QInt idx_first_col,
                                   const QInt num_col_set,
                                   const QReal *values_imag);
extern QVoid Mat_Ptr_AddRealValues(QVoid **A,
                                   const QInt idx_block_row,
                                   const QInt idx_block_col,
                                   const QInt idx_first_row,
                                   const QInt num_row_add,
                                   const QInt idx_first_col,
                                   const QInt num_col_add,
                                   const QReal *values_real);
extern QVoid Mat_Ptr_AddImagValues(QVoid **A,
                                   const QInt idx_block_row,
                                   const QInt idx_block_col,
                                   const QInt idx_first_row,
                                   const QInt num_row_add,
                                   const QInt idx_first_col,
                                   const QInt num_col_add,
                                   const QReal *values_imag);
extern QVoid Mat_Ptr_GetRealValues(QVoid **A,
                                   const QInt idx_block_row,
                                   const QInt idx_block_col,
                                   const QInt idx_first_row,
                                   const QInt num_row_get,
                                   const QInt idx_first_col,
                                   const QInt num_col_get,
                                   QReal *values_real);
extern QVoid Mat_Ptr_GetImagValues(QVoid **A,
                                   const QInt idx_block_row,
                                   const QInt idx_block_col,
                                   const QInt idx_first_row,
                                   const QInt num_row_get,
                                   const QInt idx_first_col,
                                   const QInt num_col_get,
                                   QReal *values_imag);
#elif defined(ADAPTER_BLOCK_REAL)
extern QVoid Mat_Ptr_SetValues(QVoid **A,
                               const QInt idx_block_row,
                               const QInt idx_block_col,
                               const QInt idx_first_row,
                               const QInt num_row_set,
                               const QInt idx_first_col,
                               const QInt num_col_set,
                               const QReal *values);
extern QVoid Mat_Ptr_AddValues(QVoid **A,
                               const QInt idx_block_row,
                               const QInt idx_block_col,
                               const QInt idx_first_row,
                               const QInt num_row_add,
                               const QInt idx_first_col,
                               const QInt num_col_add,
                               const QReal *values);
extern QVoid Mat_Ptr_GetValues(QVoid **A,
                               const QInt idx_block_row,
                               const QInt idx_block_col,
                               const QInt idx_first_row,
                               const QInt num_row_get,
                               const QInt idx_first_col,
                               const QInt num_col_get,
                               QReal *values);
#elif defined(ADAPTER_CMPLX_MAT)
extern QVoid Mat_Ptr_SetRealValues(QVoid **A,
                                   const QInt idx_first_row,
                                   const QInt num_row_set,
                                   const QInt idx_first_col,
                                   const QInt num_col_set,
                                   const QReal *values_real);
extern QVoid Mat_Ptr_SetImagValues(QVoid **A,
                                   const QInt idx_first_row,
                                   const QInt num_row_set,
                                   const QInt idx_first_col,
                                   const QInt num_col_set,
                                   const QReal *values_imag);
extern QVoid Mat_Ptr_AddRealValues(QVoid **A,
                                   const QInt idx_first_row,
                                   const QInt num_row_add,
                                   const QInt idx_first_col,
                                   const QInt num_col_add,
                                   const QReal *values_real);
extern QVoid Mat_Ptr_AddImagValues(QVoid **A,
                                   const QInt idx_first_row,
                                   const QInt num_row_add,
                                   const QInt idx_first_col,
                                   const QInt num_col_add,
                                   const QReal *values_imag);
extern QVoid Mat_Ptr_GetRealValues(QVoid **A,
                                   const QInt idx_first_row,
                                   const QInt num_row_get,
                                   const QInt idx_first_col,
                                   const QInt num_col_get,
                                   QReal *values_real);
extern QVoid Mat_Ptr_GetImagValues(QVoid **A,
                                   const QInt idx_first_row,
                                   const QInt num_row_get,
                                   const QInt idx_first_col,
                                   const QInt num_col_get,
                                   QReal *values_imag);
#else
extern QVoid Mat_Ptr_SetValues(QVoid **A,
                               const QInt idx_first_row,
                               const QInt num_row_set,
                               const QInt idx_first_col,
                               const QInt num_col_set,
                               const QReal *values);
extern QVoid Mat_Ptr_AddValues(QVoid **A,
                               const QInt idx_first_row,
                               const QInt num_row_add,
                               const QInt idx_first_col,
                               const QInt num_col_add,
                               const QReal *values);
extern QVoid Mat_Ptr_GetValues(QVoid **A,
                               const QInt idx_first_row,
                               const QInt num_row_get,
                               const QInt idx_first_col,
                               const QInt num_col_get,
                               QReal *values);
#endif
extern QVoid Mat_Ptr_Duplicate(QVoid **A, const QInt duplicate_option, QVoid **B);
extern QVoid Mat_Ptr_ZeroEntries(QVoid **A);
#if defined(ADAPTER_BLOCK_CMPLX)
extern QVoid Mat_Ptr_GetTrace(QVoid **A, const QInt num_blocks, QReal *trace);
extern QVoid Mat_Ptr_GetMatProdTrace(QVoid **A,
                                     QVoid **B,
                                     const QInt op_B,
                                     const QInt num_blocks,
                                     QReal *trace);
#elif defined(ADAPTER_BLOCK_REAL)
extern QVoid Mat_Ptr_GetTrace(QVoid **A, const QInt num_blocks, QReal *trace);
extern QVoid Mat_Ptr_GetMatProdTrace(QVoid **A,
                                     QVoid **B,
                                     const QInt op_B,
                                     const QInt num_blocks,
                                     QReal *trace);
#elif defined(ADAPTER_CMPLX_MAT)
extern QVoid Mat_Ptr_GetTrace(QVoid **A, QReal *trace);
extern QVoid Mat_Ptr_GetMatProdTrace(QVoid **A,
                                     QVoid **B,
                                     const QInt op_B,
                                     QReal *trace);
#else
extern QVoid Mat_Ptr_GetTrace(QVoid **A, QReal *trace);
extern QVoid Mat_Ptr_GetMatProdTrace(QVoid **A,
                                     QVoid **B,
                                     const QInt op_B,
                                     QReal *trace);
#endif
#if defined(QCMATRIX_ENABLE_VIEW)
extern QVoid Mat_Ptr_Write(QVoid **A,
                           const QInt len_mat_label,
                           const QChar *mat_label,
                           const QInt view_option);
#endif
#if defined(QCMATRIX_ENABLE_VIEW)
extern QVoid Mat_Ptr_Read(QVoid **A,
                          const QInt len_mat_label,
                          const QChar *mat_label,
                          const QInt view_option);
#endif
#if defined(ADAPTER_BLOCK_CMPLX) || defined(ADAPTER_CMPLX_MAT)
extern QVoid Mat_Ptr_Scale(const QReal *scal_number, QVoid **A);
#else
extern QVoid Mat_Ptr_Scale(const QReal scal_number, QVoid **A);
#endif
#if defined(ADAPTER_BLOCK_CMPLX) || defined(ADAPTER_CMPLX_MAT)
extern QVoid Mat_Ptr_AXPY(const QReal *multiplier, QVoid **X, QVoid **Y);
#else
extern QVoid Mat_Ptr_AXPY(const QReal multiplier, QVoid **X, QVoid **Y);
#endif
extern QVoid Mat_Ptr_Transpose(const QInt op_A, QVoid **A, QVoid **B);
#if defined(ADAPTER_BLOCK_CMPLX) || defined(ADAPTER_CMPLX_MAT)
extern QVoid Mat_Ptr_GEMM(const QInt op_A,
                          const QInt op_B,
                          const QReal *alpha,
                          QVoid **A,
                          QVoid **B,
                          const QReal *beta,
                          QVoid **C);
#else
extern QVoid Mat_Ptr_GEMM(const QInt op_A,
                          const QInt op_B,
                          const QReal alpha,
                          QVoid **A,
                          QVoid **B,
                          const QReal beta,
                          QVoid **C);
#endif

QErrorCode AdapterMatCreate(AdapterMat *A)
{
    Mat_Ptr_Create(&A->f03_mat);
    A->external_mat = QFALSE;
    return QSUCCESS;
}

QErrorCode AdapterMatDestroy(AdapterMat *A)
{
    if (A->external_mat==QFALSE) {
        Mat_Ptr_Destroy(&A->f03_mat);
    }
    return QSUCCESS;
}

#if defined(ADAPTER_BLOCK_CMPLX) || defined(ADAPTER_BLOCK_REAL)
QErrorCode AdapterMatBlockCreate(AdapterMat *A, const QInt dim_block)
{
    Mat_Ptr_BlockCreate(&A->f03_mat, dim_block);
    return QSUCCESS;
}
#endif

QErrorCode AdapterMatSetSymType(AdapterMat *A, const QcSymType sym_type)
{
    /* converts symmetry types, to be consistent with
       include/api/qcmatrix_f_mat_symmetry.h90 and include/types/mat_symmetry.h */
    QInt def_sym_type[3]={-1,0,1};
    Mat_Ptr_SetSymType(&A->f03_mat, def_sym_type[sym_type+1]);
    return QSUCCESS;
}

#if defined(ADAPTER_BLOCK_CMPLX)
QErrorCode AdapterMatSetDataType(AdapterMat *A,
                                 const QInt num_blocks,
                                 const QInt idx_block_row[],
                                 const QInt idx_block_col[],
                                 const QcDataType data_type[])
{
    /* defined data types, to be consistent with
       include/api/qcmatrix_f_mat_data.h90 and include/types/mat_data.h */
    QInt def_data_type[4]={-1,0,1,2};
    QInt *f_data_type;
    QInt iblk;
    f_data_type = (QInt *)malloc(num_blocks*sizeof(QInt));
    if (f_data_type==NULL) {
        QErrorExit(FILE_AND_LINE, "failed to allocate memory for f_data_type");
    }
    for (iblk=0; iblk<num_blocks; iblk++) {
        f_data_type[iblk] = def_data_type[data_type[iblk]+1];
    }
    Mat_Ptr_SetDataType(&A->f03_mat,
                        num_blocks,
                        idx_block_row,
                        idx_block_col,
                        f_data_type);
    free(f_data_type);
    f_data_type = NULL;
    return QSUCCESS;
}
#elif defined(ADAPTER_BLOCK_REAL)
QErrorCode AdapterMatSetNonZeroBlocks(AdapterMat *A,
                                      const QInt num_blocks,
                                      const QInt idx_block_row[],
                                      const QInt idx_block_col[])
{
    Mat_Ptr_SetNonZeroBlocks(&A->f03_mat, num_blocks, idx_block_row, idx_block_col);
    return QSUCCESS;
}
#elif defined(ADAPTER_CMPLX_MAT)
QErrorCode AdapterMatSetDataType(AdapterMat *A, const QcDataType data_type)
{
    /* defined data types, to be consistent with
       include/api/qcmatrix_f_mat_data.h90 and include/types/mat_data.h */
    QInt def_data_type[4]={-1,0,1,2};
    Mat_Ptr_SetDataType(&A->f03_mat, def_data_type[data_type+1]);
    return QSUCCESS;
}
#endif

QErrorCode AdapterMatSetDimMat(AdapterMat *A, const QInt num_row, const QInt num_col)
{
    Mat_Ptr_SetDimMat(&A->f03_mat, num_row, num_col);
    return QSUCCESS;
}

#if defined(QCMATRIX_STORAGE_MODE)
/* FIXME: converts QcStorageMode to QInt */
QErrorCode AdapterMatSetStorageMode(AdapterMat *A, const QcStorageMode storage_mode)
{
    Mat_Ptr_SetStorageMode(&A->f03_mat, storage_mode);
    return QSUCCESS;
}
#endif

QErrorCode AdapterMatAssemble(AdapterMat *A)
{
    Mat_Ptr_Assemble(&A->f03_mat);
    return QSUCCESS;
}

#if defined(ADAPTER_BLOCK_CMPLX) || defined(ADAPTER_BLOCK_REAL)
QErrorCode AdapterMatGetDimBlock(AdapterMat *A, QInt *dim_block)
{
    Mat_Ptr_GetDimBlock(&A->f03_mat, dim_block);
    return QSUCCESS;
}
#endif

QErrorCode AdapterMatGetSymType(AdapterMat *A, QcSymType *sym_type)
{
    /* defined symmetry types, to be consistent with include/api/qcmatrix_f_mat_symmetry.h90 */
    QcSymType def_sym_type[3]={QANTISYMMAT,QNONSYMMAT,QSYMMAT};
    QInt f_sym_type;
    Mat_Ptr_GetSymType(&A->f03_mat, &f_sym_type);
    *sym_type = def_sym_type[f_sym_type+1];
    return QSUCCESS;
}

#if defined(ADAPTER_BLOCK_CMPLX)
QErrorCode AdapterMatGetDataType(AdapterMat *A,
                                 const QInt num_blocks,
                                 const QInt idx_block_row[],
                                 const QInt idx_block_col[],
                                 QcDataType *data_type)
{
    /* defined data types, to be consistent with include/api/qcmatrix_f_mat_data.h90 */
    QcDataType def_data_type[4]={QIMAGMAT,QCMPLXMAT,QREALMAT,QNULLMAT};
    QInt *f_data_type;
    QInt iblk;
    f_data_type = (QInt *)malloc(num_blocks*sizeof(QInt));
    if (f_data_type==NULL) {
        QErrorExit(FILE_AND_LINE, "failed to allocate memory for f_data_type");
    }
    Mat_Ptr_GetDataType(&A->f03_mat,
                        num_blocks,
                        idx_block_row,
                        idx_block_col,
                        f_data_type);
    for (iblk=0; iblk<num_blocks; iblk++) {
        data_type[iblk] = def_data_type[f_data_type[iblk]+1];
    }
    free(f_data_type);
    f_data_type = NULL;
    return QSUCCESS;
}
#elif defined(ADAPTER_BLOCK_REAL)
QErrorCode AdapterMatGetNonZeroBlocks(AdapterMat *A,
                                      const QInt num_blocks,
                                      const QInt idx_block_row[],
                                      const QInt idx_block_col[],
                                      QBool *is_non_zero)
{
    /* Boolean type, to be consistent with
       include/api/qcmatrix_f_boolean.h90 and include/types/qcmatrix_basic_types.h */
    QBool c_Boolean[2]={QFALSE,QTRUE};
    QInt *f_is_non_zero;
    f_is_non_zero = (QInt *)malloc(num_blocks*sizeof(QInt));
    if (f_is_non_zero==NULL) {
        QErrorExit(FILE_AND_LINE, "failed to allocate memory for f_is_non_zero");
    }
    Mat_Ptr_GetNonZeroBlocks(&A->f03_mat,
                             num_blocks,
                             idx_block_row,
                             idx_block_col,
                             f_is_non_zero);
    for (iblk=0; iblk<num_blocks; iblk++) {
        is_non_zero[iblk] = c_Boolean[f_is_non_zero[iblk]];
    }
    free(f_is_non_zero);
    f_is_non_zero = NULL;
    return QSUCCESS;
}
#elif defined(ADAPTER_CMPLX_MAT)
QErrorCode AdapterMatGetDataType(AdapterMat *A, QcDataType *data_type)
{
    /* defined data types, to be consistent with include/api/qcmatrix_f_mat_data.h90 */
    QcDataType def_data_type[4]={QIMAGMAT,QCMPLXMAT,QREALMAT,QNULLMAT};
    QInt f_data_type;
    Mat_Ptr_GetDataType(&A->f03_mat, &f_data_type);
    *data_type = def_data_type[f_data_type+1];
    return QSUCCESS;
}
#endif

QErrorCode AdapterMatGetDimMat(AdapterMat *A, QInt *num_row, QInt *num_col)
{
    Mat_Ptr_GetDimMat(&A->f03_mat, num_row, num_col);
    return QSUCCESS;
}

#if defined(QCMATRIX_STORAGE_MODE)
/* FIXME: converts QcStorageMode to QInt */
QErrorCode AdapterMatGetStorageMode(AdapterMat *A, QcStorageMode *storage_mode)
{
    Mat_Ptr_GetStorageMode(&A->f03_mat, storage_mode);
    return QSUCCESS;
}
#endif

QErrorCode AdapterMatIsAssembled(AdapterMat *A, QBool *assembled)
{
    /* Boolean type, to be consistent with
       include/api/qcmatrix_f_boolean.h90 and include/types/qcmatrix_basic_types.h */
    QBool c_Boolean[2]={QFALSE,QTRUE};
    QInt f_assembled;
    Mat_Ptr_IsAssembled(&A->f03_mat, &f_assembled);
    *assembled = c_Boolean[f_assembled];
    return QSUCCESS;
}

#if defined(ADAPTER_BLOCK_CMPLX)
QErrorCode AdapterMatSetValues(AdapterMat *A,
                               const QInt idx_block_row,
                               const QInt idx_block_col,
                               const QInt idx_first_row,
                               const QInt num_row_set,
                               const QInt idx_first_col,
                               const QInt num_col_set,
                               const QReal *values_real,
                               const QReal *values_imag)
{
    if (values_real!=NULL) {
        Mat_Ptr_SetRealValues(&A->f03_mat,
                              idx_block_row,
                              idx_block_col,
                              idx_first_row,
                              num_row_set,
                              idx_first_col,
                              num_col_set,
                              values_real);
    }
    if (values_imag!=NULL) {
        Mat_Ptr_SetImagValues(&A->f03_mat,
                              idx_block_row,
                              idx_block_col,
                              idx_first_row,
                              num_row_set,
                              idx_first_col,
                              num_col_set,
                              values_imag);
    }
    return QSUCCESS;
}

QErrorCode AdapterMatAddValues(AdapterMat *A,
                               const QInt idx_block_row,
                               const QInt idx_block_col,
                               const QInt idx_first_row,
                               const QInt num_row_add,
                               const QInt idx_first_col,
                               const QInt num_col_add,
                               const QReal *values_real,
                               const QReal *values_imag)
{
    if (values_real!=NULL) {
        Mat_Ptr_AddRealValues(&A->f03_mat,
                              idx_block_row,
                              idx_block_col,
                              idx_first_row,
                              num_row_add,
                              idx_first_col,
                              num_col_add,
                              values_real);
    }
    if (values_imag!=NULL) {
        Mat_Ptr_AddImagValues(&A->f03_mat,
                              idx_block_row,
                              idx_block_col,
                              idx_first_row,
                              num_row_add,
                              idx_first_col,
                              num_col_add,
                              values_imag);
    }
    return QSUCCESS;
}

QErrorCode AdapterMatGetValues(AdapterMat *A,
                               const QInt idx_block_row,
                               const QInt idx_block_col,
                               const QInt idx_first_row,
                               const QInt num_row_get,
                               const QInt idx_first_col,
                               const QInt num_col_get,
                               QReal *values_real,
                               QReal *values_imag)
{
    if (values_real!=NULL) {
        Mat_Ptr_GetRealValues(&A->f03_mat,
                              idx_block_row,
                              idx_block_col,
                              idx_first_row,
                              num_row_get,
                              idx_first_col,
                              num_col_get,
                              values_real);
    }
    if (values_imag!=NULL) {
        Mat_Ptr_GetImagValues(&A->f03_mat,
                              idx_block_row,
                              idx_block_col,
                              idx_first_row,
                              num_row_get,
                              idx_first_col,
                              num_col_get,
                              values_imag);
    }
    return QSUCCESS;              
}
#elif defined(ADAPTER_BLOCK_REAL)
QErrorCode AdapterMatSetValues(AdapterMat *A,
                               const QInt idx_block_row,
                               const QInt idx_block_col,
                               const QInt idx_first_row,
                               const QInt num_row_set,
                               const QInt idx_first_col,
                               const QInt num_col_set,
                               const QReal *values)
{
    Mat_Ptr_SetValues(&A->f03_mat,
                      idx_block_row,
                      idx_block_col,
                      idx_first_row,
                      num_row_set,
                      idx_first_col,
                      num_col_set,
                      values);
    return QSUCCESS;
}

QErrorCode AdapterMatAddValues(AdapterMat *A,
                               const QInt idx_block_row,
                               const QInt idx_block_col,
                               const QInt idx_first_row,
                               const QInt num_row_add,
                               const QInt idx_first_col,
                               const QInt num_col_add,
                               const QReal *values)
{
    Mat_Ptr_AddValues(&A->f03_mat,
                      idx_block_row,
                      idx_block_col,
                      idx_first_row,
                      num_row_add,
                      idx_first_col,
                      num_col_add,
                      values);
    return QSUCCESS;
}

QErrorCode AdapterMatGetValues(AdapterMat *A,
                               const QInt idx_block_row,
                               const QInt idx_block_col,
                               const QInt idx_first_row,
                               const QInt num_row_get,
                               const QInt idx_first_col,
                               const QInt num_col_get,
                               QReal *values)
{
    Mat_Ptr_GetValues(&A->f03_mat,
                      idx_block_row,
                      idx_block_col,
                      idx_first_row,
                      num_row_get,
                      idx_first_col,
                      num_col_get,
                      values);
    return QSUCCESS;
}
#elif defined(ADAPTER_CMPLX_MAT)
QErrorCode AdapterMatSetValues(AdapterMat *A,
                               const QInt idx_first_row,
                               const QInt num_row_set,
                               const QInt idx_first_col,
                               const QInt num_col_set,
                               const QReal *values_real,
                               const QReal *values_imag)
{
    if (values_real!=NULL) {
        Mat_Ptr_SetRealValues(&A->f03_mat,
                              idx_first_row,
                              num_row_set,
                              idx_first_col,
                              num_col_set,
                              values_real);
    }
    if (values_imag!=NULL) {
        Mat_Ptr_SetImagValues(&A->f03_mat,                      
                              idx_first_row,
                              num_row_set,
                              idx_first_col,
                              num_col_set,
                              values_imag);
    }
    return QSUCCESS;
}

QErrorCode AdapterMatAddValues(AdapterMat *A,
                               const QInt idx_first_row,
                               const QInt num_row_add,
                               const QInt idx_first_col,
                               const QInt num_col_add,
                               const QReal *values_real,
                               const QReal *values_imag)
{
    if (values_real!=NULL) {
        Mat_Ptr_AddRealValues(&A->f03_mat,
                              idx_first_row,
                              num_row_add,
                              idx_first_col,
                              num_col_add,
                              values_real);
    }
    if (values_imag!=NULL) {
        Mat_Ptr_AddImagValues(&A->f03_mat,
                              idx_first_row,
                              num_row_add,
                              idx_first_col,
                              num_col_add,
                              values_imag);
    }
    return QSUCCESS;
}

QErrorCode AdapterMatGetValues(AdapterMat *A,
                               const QInt idx_first_row,
                               const QInt num_row_get,
                               const QInt idx_first_col,
                               const QInt num_col_get,
                               QReal *values_real,
                               QReal *values_imag)
{
    if (values_real!=NULL) {
        Mat_Ptr_GetRealValues(&A->f03_mat,
                              idx_first_row,
                              num_row_get,
                              idx_first_col,
                              num_col_get,
                              values_real);
    }
    if (values_imag!=NULL) {
        Mat_Ptr_GetImagValues(&A->f03_mat,
                              idx_first_row,
                              num_row_get,
                              idx_first_col,
                              num_col_get,
                              values_imag);
    }
    return QSUCCESS;
}
#else
QErrorCode AdapterMatSetValues(AdapterMat *A,
                               const QInt idx_first_row,
                               const QInt num_row_set,
                               const QInt idx_first_col,
                               const QInt num_col_set,
                               const QReal *values)
{
    Mat_Ptr_SetValues(&A->f03_mat,
                      idx_first_row,
                      num_row_set,
                      idx_first_col,
                      num_col_set,
                      values);
    return QSUCCESS;
}

QErrorCode AdapterMatAddValues(AdapterMat *A,
                               const QInt idx_first_row,
                               const QInt num_row_add,
                               const QInt idx_first_col,
                               const QInt num_col_add,
                               const QReal *values)
{
    Mat_Ptr_AddValues(&A->f03_mat,
                      idx_first_row,
                      num_row_add,
                      idx_first_col,
                      num_col_add,
                      values);
    return QSUCCESS;
}

QErrorCode AdapterMatGetValues(AdapterMat *A,
                               const QInt idx_first_row,
                               const QInt num_row_get,
                               const QInt idx_first_col,
                               const QInt num_col_get,
                               QReal *values)
{
    Mat_Ptr_GetValues(&A->f03_mat,
                      idx_first_row,
                      num_row_get,
                      idx_first_col,
                      num_col_get,
                      values);
    return QSUCCESS;
}
#endif

QErrorCode AdapterMatDuplicate(AdapterMat *A,
                               const QcDuplicateOption duplicate_option,
                               AdapterMat *B)
{
    /* defined duplicate option, to be consistent with
       include/api/qcmatrix_f_mat_duplicate.h90 and include/types/mat_duplicate.h */
    QInt def_dup_option[2]={0,1};
    Mat_Ptr_Duplicate(&A->f03_mat, def_dup_option[duplicate_option], &B->f03_mat);
    return QSUCCESS;
}

QErrorCode AdapterMatZeroEntries(AdapterMat *A)
{
    Mat_Ptr_ZeroEntries(&A->f03_mat);
    return QSUCCESS;
}

#if defined(ADAPTER_BLOCK_CMPLX)
QErrorCode AdapterMatGetTrace(AdapterMat *A, const QInt num_blocks, QReal *trace)
{
    Mat_Ptr_GetTrace(&A->f03_mat, num_blocks, trace);
    return QSUCCESS;
}

QErrorCode AdapterMatGetMatProdTrace(AdapterMat *A,
                                     AdapterMat *B,
                                     const QcMatOperation op_B,
                                     const QInt num_blocks,
                                     QReal *trace)
{
    /* defined operations on the matrix, to be consistent with
       include/api/qcmatrix_f_mat_operations.h90 and include/types/mat_operations.h */
    QInt def_mat_op[4]={0,1,2,3};
    Mat_Ptr_GetMatProdTrace(&A->f03_mat,
                            &B->f03_mat,
                            def_mat_op[op_B],
                            num_blocks,
                            trace);
    return QSUCCESS;
}
#elif defined(ADAPTER_BLOCK_REAL)
QErrorCode AdapterMatGetTrace(AdapterMat *A, const QInt num_blocks, QReal *trace)
{
    Mat_Ptr_GetTrace(&A->f03_mat, num_blocks, trace);
    return QSUCCESS;
}

QErrorCode AdapterMatGetMatProdTrace(AdapterMat *A,
                                     AdapterMat *B,
                                     const QcMatOperation op_B,
                                     const QInt num_blocks,
                                     QReal *trace)
{
    /* defined operations on the matrix, to be consistent with
       include/api/qcmatrix_f_mat_operations.h90 and include/types/mat_operations.h */
    QInt def_mat_op[4]={0,1,2,3};
    Mat_Ptr_GetMatProdTrace(&A->f03_mat,
                            &B->f03_mat,
                            def_mat_op[op_B],
                            num_blocks,
                            trace);
    return QSUCCESS;
}
#elif defined(ADAPTER_CMPLX_MAT)
QErrorCode AdapterMatGetTrace(AdapterMat *A, QReal *trace)
{
    Mat_Ptr_GetTrace(&A->f03_mat, trace);
    return QSUCCESS;
}

QErrorCode AdapterMatGetMatProdTrace(AdapterMat *A,
                                     AdapterMat *B,
                                     const QcMatOperation op_B,
                                     QReal *trace)
{
    /* defined operations on the matrix, to be consistent with
       include/api/qcmatrix_f_mat_operations.h90 and include/types/mat_operations.h */
    QInt def_mat_op[4]={0,1,2,3};
    Mat_Ptr_GetMatProdTrace(&A->f03_mat, &B->f03_mat, def_mat_op[op_B], trace);
    return QSUCCESS;
}
#else
QErrorCode AdapterMatGetTrace(AdapterMat *A, QReal *trace)
{
    Mat_Ptr_GetTrace(&A->f03_mat, trace);
    return QSUCCESS;
}

QErrorCode AdapterMatGetMatProdTrace(AdapterMat *A,
                                     AdapterMat *B, 
                                     const QcMatOperation op_B, 
                                     QReal *trace)
{
    /* defined operations on the matrix, to be consistent with
       include/api/qcmatrix_f_mat_operations.h90 and include/types/mat_operations.h */
    QInt def_mat_op[4]={0,1,2,3};
    Mat_Ptr_GetMatProdTrace(&A->f03_mat, &B->f03_mat, def_mat_op[op_B], trace);
    return QSUCCESS;
}
#endif

#if defined(QCMATRIX_ENABLE_VIEW)
QErrorCode AdapterMatWrite(AdapterMat *A,
                           const QChar *mat_label,
                           const QcViewOption view_option)
{
    /* defined view option, to be consistend with
       include/api/qcmatrix_f_mat_view.h90 and include/types/mat_view.h */
    QInt def_view_option[2]={0,1};
    QInt len_mat_label = strlen(mat_label);
    Mat_Ptr_Write(&A->f03_mat, len_mat_label, mat_label, def_view_option[view_option]);
    return QSUCCESS;
}
#endif

#if defined(QCMATRIX_ENABLE_VIEW)
QErrorCode AdapterMatRead(AdapterMat *A,
                          const QChar *mat_label,
                          const QcViewOption view_option)
{
    /* defined view option, to be consistend with
       include/api/qcmatrix_f_mat_view.h90 and include/types/mat_view.h */
    QInt def_view_option[2]={0,1};
    QInt len_mat_label = strlen(mat_label);
    Mat_Ptr_Read(&A->f03_mat, len_mat_label, mat_label, def_view_option[view_option]);
    return QSUCCESS;
}
#endif

#if defined(ADAPTER_BLOCK_CMPLX) || defined(ADAPTER_CMPLX_MAT)
QErrorCode AdapterMatScale(const QReal scal_number[], AdapterMat *A)
{
    Mat_Ptr_Scale(scal_number, &A->f03_mat);
    return QSUCCESS;
}
#else
QErrorCode AdapterMatScale(const QReal scal_number, AdapterMat *A)
{
    Mat_Ptr_Scale(scal_number, &A->f03_mat);
    return QSUCCESS;
}
#endif

#if defined(ADAPTER_BLOCK_CMPLX) || defined(ADAPTER_CMPLX_MAT)
QErrorCode AdapterMatAXPY(const QReal multiplier[], AdapterMat *X, AdapterMat *Y)
{
    Mat_Ptr_AXPY(multiplier, &X->f03_mat, &Y->f03_mat);
    return QSUCCESS;
}
#else
QErrorCode AdapterMatAXPY(const QReal multiplier, AdapterMat *X, AdapterMat *Y)
{
    Mat_Ptr_AXPY(multiplier, &X->f03_mat, &Y->f03_mat);
    return QSUCCESS;
}
#endif

QErrorCode AdapterMatTranspose(const QcMatOperation op_A, AdapterMat *A, AdapterMat *B)
{
    /* defined operations on the matrix, to be consistent with
       include/api/qcmatrix_f_mat_operations.h90 and include/types/mat_operations.h */
    QInt def_mat_op[4]={0,1,2,3};
    Mat_Ptr_Transpose(def_mat_op[op_A], &A->f03_mat, &B->f03_mat);
    return QSUCCESS;
}

#if defined(ADAPTER_BLOCK_CMPLX) || defined(ADAPTER_CMPLX_MAT)
QErrorCode AdapterMatGEMM(const QcMatOperation op_A,
                          const QcMatOperation op_B,
                          const QReal alpha[],
                          AdapterMat *A,
                          AdapterMat *B,
                          const QReal beta[],
                          AdapterMat *C)
{
    /* defined operations on the matrix, to be consistent with
       include/api/qcmatrix_f_mat_operations.h90 and include/types/mat_operations.h */
    QInt def_mat_op[4]={0,1,2,3};
    Mat_Ptr_GEMM(def_mat_op[op_A],
                 def_mat_op[op_B],
                 alpha,
                 &A->f03_mat,
                 &B->f03_mat,
                 beta,
                 &C->f03_mat);
    return QSUCCESS;
}
#else
QErrorCode AdapterMatGEMM(const QcMatOperation op_A,
                          const QcMatOperation op_B,
                          const QReal alpha,
                          AdapterMat *A,
                          AdapterMat *B,
                          const QReal beta,
                          AdapterMat *C)
{
    /* defined operations on the matrix, to be consistent with
       include/api/qcmatrix_f_mat_operations.h90 and include/types/mat_operations.h */
    QInt def_mat_op[4]={0,1,2,3};
    Mat_Ptr_GEMM(def_mat_op[op_A],
                 def_mat_op[op_B],
                 alpha,
                 &A->f03_mat,
                 &B->f03_mat,
                 beta,
                 &C->f03_mat);
    return QSUCCESS;
}
#endif

QErrorCode AdapterMatSetExternalMat(AdapterMat *A, QVoid **f_A)
{
    QErrorCode err_code;
    err_code = AdapterMatDestroy(A);
    QErrorCheckCode(err_code, FILE_AND_LINE, "calling AdapterMatDestroy");
    A->f03_mat = *f_A;
    A->external_mat = QTRUE;
    return QSUCCESS;
}

QErrorCode AdapterMatGetExternalMat(AdapterMat *A, QVoid **f_A)
{
    *f_A = (QVoid *)A->f03_mat;  /* the pointer itself can not be changed on exit, but its content does */
    return QSUCCESS;
}
