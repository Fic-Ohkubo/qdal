!!  QcMatrix: an abstract matrix library
!!  Copyright 2012-2015 Bin Gao
!!
!!  QcMatrix is free software: you can redistribute it and/or modify
!!  it under the terms of the GNU Lesser General Public License as published by
!!  the Free Software Foundation, either version 3 of the License, or
!!  (at your option) any later version.
!!
!!  QcMatrix is distributed in the hope that it will be useful,
!!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
!!  GNU Lesser General Public License for more details.
!!
!!  You should have received a copy of the GNU Lesser General Public License
!!  along with QcMatrix. If not, see <http://www.gnu.org/licenses/>.
!!
!!  This file provides an adapter between QcMatrix and external Fortran 90
!!  matrix library.
!!
!!  2014-03-11, Bin Gao:
!!  * generated by tools/qcmatrix_fortran.py

! checks if the external Fortran module and matrix type are given
#include "adapter/check_f_mod.h"

! SIZEOF_F_TYPE_P is the size in bytes of derived types with a single pointer member,
! could be changed by -DSIZEOF_F_TYPE_P=XX
#include "adapter/sizeof_f_type_p.h"

module f90_adapter
    ! includes matrix type and relevant subroutines from external Fortran 90 module
    use LANG_F_MODULE, only: LANG_F_MATRIX

    implicit none

    ! derived type in which the single pointer member points to the matrix in
    ! external Fortran 90 module; the idea is from Comput. Sci. Eng. 10, 86 (2008)
    type matrix_ptr_t
        private
        type(LANG_F_MATRIX), pointer :: f90_mat
    end type matrix_ptr_t

! basic data types
#include "api/qcmatrix_f_basic.h90"

    contains

    subroutine Mat_Ptr_Create(iA)
        use LANG_F_MODULE, only: Matrix_Create
        implicit none
        integer(kind=QINT), intent(out) :: iA(SIZEOF_F_TYPE_P)
        type(matrix_ptr_t) A
        allocate(A%f90_mat)
        call Matrix_Create(A%f90_mat)
        iA = transfer(A, iA)
        return
    end subroutine Mat_Ptr_Create

    subroutine Mat_Ptr_Destroy(iA)
        use LANG_F_MODULE, only: Matrix_Destroy
        implicit none
        integer(kind=QINT), intent(inout) :: iA(SIZEOF_F_TYPE_P)
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_Destroy(A%f90_mat)
        deallocate(A%f90_mat)
        nullify(A%f90_mat)
        iA = 0
        return
    end subroutine Mat_Ptr_Destroy

#if defined(ADAPTER_BLOCK_CMPLX) || defined(ADAPTER_BLOCK_REAL)
    subroutine Mat_Ptr_BlockCreate(iA, dim_block)
        use LANG_F_MODULE, only: Matrix_BlockCreate
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: dim_block
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_BlockCreate(A%f90_mat, dim_block)
        return
    end subroutine Mat_Ptr_BlockCreate
#endif

    subroutine Mat_Ptr_SetSymType(iA, sym_type)
        use LANG_F_MODULE, only: Matrix_SetSymType
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: sym_type
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_SetSymType(A%f90_mat, sym_type)
        return
    end subroutine Mat_Ptr_SetSymType

#if defined(ADAPTER_BLOCK_CMPLX)
    subroutine Mat_Ptr_SetDataType(iA,            &
                                   num_blocks,    &
                                   idx_block_row, &
                                   idx_block_col, &
                                   data_type)
        use LANG_F_MODULE, only: Matrix_SetDataType
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: num_blocks
        integer(kind=QINT), intent(in) :: idx_block_row(num_blocks)
        integer(kind=QINT), intent(in) :: idx_block_col(num_blocks)
        integer(kind=QINT), intent(in) :: data_type(num_blocks)
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_SetDataType(A%f90_mat,     &
                                num_blocks,    &
                                idx_block_row, &
                                idx_block_col, &
                                data_type)
        return
    end subroutine Mat_Ptr_SetDataType
#elif defined(ADAPTER_BLOCK_REAL)
    subroutine Mat_Ptr_SetNonZeroBlocks(iA, num_blocks, idx_block_row, idx_block_col)
        use LANG_F_MODULE, only: Matrix_SetNonZeroBlocks
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: num_blocks
        integer(kind=QINT), intent(in) :: idx_block_row(num_blocks)
        integer(kind=QINT), intent(in) :: idx_block_col(num_blocks)
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_SetNonZeroBlocks(A%f90_mat, num_blocks, idx_block_row, idx_block_col)
        return
    end subroutine Mat_Ptr_SetNonZeroBlocks
#elif defined(ADAPTER_CMPLX_MAT)
    subroutine Mat_Ptr_SetDataType(iA, data_type)
        use LANG_F_MODULE, only: Matrix_SetDataType
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: data_type
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_SetDataType(A%f90_mat, data_type)
        return
    end subroutine Mat_Ptr_SetDataType
#endif

    subroutine Mat_Ptr_SetDimMat(iA, num_row, num_col)
        use LANG_F_MODULE, only: Matrix_SetDimMat
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: num_row
        integer(kind=QINT), intent(in) :: num_col
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_SetDimMat(A%f90_mat, num_row, num_col)
        return
    end subroutine Mat_Ptr_SetDimMat

#if defined(QCMATRIX_STORAGE_MODE)
    subroutine Mat_Ptr_SetStorageMode(iA, storage_mode)
        use LANG_F_MODULE, only: Matrix_SetStorageMode
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: storage_mode
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_SetStorageMode(A%f90_mat, storage_mode)
        return
    end subroutine Mat_Ptr_SetStorageMode
#endif

    subroutine Mat_Ptr_Assemble(iA)
        use LANG_F_MODULE, only: Matrix_Assemble
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_Assemble(A%f90_mat)
        return
    end subroutine Mat_Ptr_Assemble

#if defined(ADAPTER_BLOCK_CMPLX) || defined(ADAPTER_BLOCK_REAL)
    subroutine Mat_Ptr_GetDimBlock(iA, dim_block)
        use LANG_F_MODULE, only: Matrix_GetDimBlock
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(out) :: dim_block
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_GetDimBlock(A%f90_mat, dim_block)
        return
    end subroutine Mat_Ptr_GetDimBlock
#endif

    subroutine Mat_Ptr_GetSymType(iA, sym_type)
        use LANG_F_MODULE, only: Matrix_GetSymType
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(out) :: sym_type
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_GetSymType(A%f90_mat, sym_type)
        return
    end subroutine Mat_Ptr_GetSymType

#if defined(ADAPTER_BLOCK_CMPLX)
    subroutine Mat_Ptr_GetDataType(iA,            &
                                   num_blocks,    &
                                   idx_block_row, &
                                   idx_block_col, &
                                   data_type)
        use LANG_F_MODULE, only: Matrix_GetDataType
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: num_blocks
        integer(kind=QINT), intent(in) :: idx_block_row(num_blocks)
        integer(kind=QINT), intent(in) :: idx_block_col(num_blocks)
        integer(kind=QINT), intent(out) :: data_type(num_blocks)
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_GetDataType(A%f90_mat,     &
                                num_blocks,    &
                                idx_block_row, &
                                idx_block_col, &
                                data_type)
        return
    end subroutine Mat_Ptr_GetDataType
#elif defined(ADAPTER_BLOCK_REAL)
    subroutine Mat_Ptr_GetNonZeroBlocks(iA,            &
                                        num_blocks,    &
                                        idx_block_row, &
                                        idx_block_col, &
                                        is_non_zero)
        use LANG_F_MODULE, only: Matrix_GetNonZeroBlocks
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: num_blocks
        integer(kind=QINT), intent(in) :: idx_block_row(num_blocks)
        integer(kind=QINT), intent(in) :: idx_block_col(num_blocks)
        integer(kind=QINT), intent(out) :: is_non_zero(num_blocks)
        type(matrix_ptr_t) A
#include "api/qcmatrix_f_boolean.h90"
        logical(kind=4), pointer :: f_is_non_zero(:)
        integer(kind=QINT) iblk
        A = transfer(iA, A)
        allocate(f_is_non_zero(num_blocks))
        call Matrix_GetNonZeroBlocks(A%f90_mat,     &
                                     num_blocks,    &
                                     idx_block_row, &
                                     idx_block_col, &
                                     f_is_non_zero)
        do iblk = 1, num_blocks
            if (f_is_non_zero(iblk)) then
                is_non_zero(iblk) = QTRUE
            else
                is_non_zero(iblk) = QFALSE
            end if
        end do
        deallocate(f_is_non_zero)
        nullify(f_is_non_zero)
        return
    end subroutine Mat_Ptr_GetNonZeroBlocks
#elif defined(ADAPTER_CMPLX_MAT)
    subroutine Mat_Ptr_GetDataType(iA, data_type)
        use LANG_F_MODULE, only: Matrix_GetDataType
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(out) :: data_type
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_GetDataType(A%f90_mat, data_type)
        return
    end subroutine Mat_Ptr_GetDataType
#endif

    subroutine Mat_Ptr_GetDimMat(iA, num_row, num_col)
        use LANG_F_MODULE, only: Matrix_GetDimMat
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(out) :: num_row
        integer(kind=QINT), intent(out) :: num_col
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_GetDimMat(A%f90_mat, num_row, num_col)
        return
    end subroutine Mat_Ptr_GetDimMat

#if defined(QCMATRIX_STORAGE_MODE)
    subroutine Mat_Ptr_GetStorageMode(iA, storage_mode)
        use LANG_F_MODULE, only: Matrix_GetStorageMode
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(out) :: storage_mode
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_GetStorageMode(A%f90_mat, storage_mode)
        return
    end subroutine Mat_Ptr_GetStorageMode
#endif

    subroutine Mat_Ptr_IsAssembled(iA, assembled)
        use LANG_F_MODULE, only: Matrix_IsAssembled
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(out) :: assembled
        type(matrix_ptr_t) A
#include "api/qcmatrix_f_boolean.h90"
        logical(kind=4) f_assembled
        A = transfer(iA, A)
        call Matrix_IsAssembled(A%f90_mat, f_assembled)
        if (f_assembled) then
            assembled = QTRUE
        else
            assembled = QFALSE
        end if
        return
    end subroutine Mat_Ptr_IsAssembled

#if defined(ADAPTER_BLOCK_CMPLX)
    subroutine Mat_Ptr_SetRealValues(iA,            &
                                     idx_block_row, &
                                     idx_block_col, &
                                     idx_first_row, &
                                     num_row_set,   &
                                     idx_first_col, &
                                     num_col_set,   &
                                     values_real)
        use LANG_F_MODULE, only: Matrix_SetValues
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: idx_block_row
        integer(kind=QINT), intent(in) :: idx_block_col
        integer(kind=QINT), intent(in) :: idx_first_row
        integer(kind=QINT), intent(in) :: num_row_set
        integer(kind=QINT), intent(in) :: idx_first_col
        integer(kind=QINT), intent(in) :: num_col_set
        real(kind=QREAL), intent(in) :: values_real(num_row_set*num_col_set)
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_SetValues(A=A%f90_mat,                 &
                              idx_block_row=idx_block_row, &
                              idx_block_col=idx_block_col, &
                              idx_first_row=idx_first_row, &
                              num_row_set=num_row_set,     &
                              idx_first_col=idx_first_col, &
                              num_col_set=num_col_set,     &
                              values_real=values_real)
        return
    end subroutine Mat_Ptr_SetRealValues

    subroutine Mat_Ptr_SetImagValues(iA,            &
                                     idx_block_row, &
                                     idx_block_col, &
                                     idx_first_row, &
                                     num_row_set,   &
                                     idx_first_col, &
                                     num_col_set,   &
                                     values_imag)
        use LANG_F_MODULE, only: Matrix_SetValues
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: idx_block_row
        integer(kind=QINT), intent(in) :: idx_block_col
        integer(kind=QINT), intent(in) :: idx_first_row
        integer(kind=QINT), intent(in) :: num_row_set
        integer(kind=QINT), intent(in) :: idx_first_col
        integer(kind=QINT), intent(in) :: num_col_set
        real(kind=QREAL), intent(in) :: values_imag(num_row_set*num_col_set)
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_SetValues(A=A%f90_mat,                 &
                              idx_block_row=idx_block_row, &
                              idx_block_col=idx_block_col, &
                              idx_first_row=idx_first_row, &
                              num_row_set=num_row_set,     &
                              idx_first_col=idx_first_col, &
                              num_col_set=num_col_set,     &
                              values_imag=values_imag)
        return
    end subroutine Mat_Ptr_SetImagValues

    subroutine Mat_Ptr_AddRealValues(iA,            &
                                     idx_block_row, &
                                     idx_block_col, &
                                     idx_first_row, &
                                     num_row_add,   &
                                     idx_first_col, &
                                     num_col_add,   &
                                     values_real)
        use LANG_F_MODULE, only: Matrix_AddValues
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: idx_block_row
        integer(kind=QINT), intent(in) :: idx_block_col
        integer(kind=QINT), intent(in) :: idx_first_row
        integer(kind=QINT), intent(in) :: num_row_add
        integer(kind=QINT), intent(in) :: idx_first_col
        integer(kind=QINT), intent(in) :: num_col_add
        real(kind=QREAL), intent(in) :: values_real(num_row_add*num_col_add)
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_AddValues(A=A%f90_mat,                 &
                              idx_block_row=idx_block_row, &
                              idx_block_col=idx_block_col, &
                              idx_first_row=idx_first_row, &
                              num_row_add=num_row_add,     &
                              idx_first_col=idx_first_col, &
                              num_col_add=num_col_add,     &
                              values_real=values_real)
        return
    end subroutine Mat_Ptr_AddRealValues

    subroutine Mat_Ptr_AddImagValues(iA,            &
                                     idx_block_row, &
                                     idx_block_col, &
                                     idx_first_row, &
                                     num_row_add,   &
                                     idx_first_col, &
                                     num_col_add,   &
                                     values_imag)
        use LANG_F_MODULE, only: Matrix_AddValues
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: idx_block_row
        integer(kind=QINT), intent(in) :: idx_block_col
        integer(kind=QINT), intent(in) :: idx_first_row
        integer(kind=QINT), intent(in) :: num_row_add
        integer(kind=QINT), intent(in) :: idx_first_col
        integer(kind=QINT), intent(in) :: num_col_add
        real(kind=QREAL), intent(in) :: values_imag(num_row_add*num_col_add)
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_AddValues(A=A%f90_mat,                 &
                              idx_block_row=idx_block_row, &
                              idx_block_col=idx_block_col, &
                              idx_first_row=idx_first_row, &
                              num_row_add=num_row_add,     &
                              idx_first_col=idx_first_col, &
                              num_col_add=num_col_add,     &
                              values_imag=values_imag)
        return
    end subroutine Mat_Ptr_AddImagValues

    subroutine Mat_Ptr_GetRealValues(iA,            &
                                     idx_block_row, &
                                     idx_block_col, &
                                     idx_first_row, &
                                     num_row_get,   &
                                     idx_first_col, &
                                     num_col_get,   &
                                     values_real)
        use LANG_F_MODULE, only: Matrix_GetValues
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: idx_block_row
        integer(kind=QINT), intent(in) :: idx_block_col
        integer(kind=QINT), intent(in) :: idx_first_row
        integer(kind=QINT), intent(in) :: num_row_get
        integer(kind=QINT), intent(in) :: idx_first_col
        integer(kind=QINT), intent(in) :: num_col_get
        real(kind=QREAL), intent(out) :: values_real(num_row_get*num_col_get)
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_GetValues(A=A%f90_mat,                 &
                              idx_block_row=idx_block_row, &
                              idx_block_col=idx_block_col, &
                              idx_first_row=idx_first_row, &
                              num_row_get=num_row_get,     &
                              idx_first_col=idx_first_col, &
                              num_col_get=num_col_get,     &
                              values_real=values_real)
        return
    end subroutine Mat_Ptr_GetRealValues

    subroutine Mat_Ptr_GetImagValues(iA,            &
                                     idx_block_row, &
                                     idx_block_col, &
                                     idx_first_row, &
                                     num_row_get,   &
                                     idx_first_col, &
                                     num_col_get,   &
                                     values_imag)
        use LANG_F_MODULE, only: Matrix_GetValues
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: idx_block_row
        integer(kind=QINT), intent(in) :: idx_block_col
        integer(kind=QINT), intent(in) :: idx_first_row
        integer(kind=QINT), intent(in) :: num_row_get
        integer(kind=QINT), intent(in) :: idx_first_col
        integer(kind=QINT), intent(in) :: num_col_get
        real(kind=QREAL), intent(out) :: values_imag(num_row_get*num_col_get)
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_GetValues(A=A%f90_mat,                 &
                              idx_block_row=idx_block_row, &
                              idx_block_col=idx_block_col, &
                              idx_first_row=idx_first_row, &
                              num_row_get=num_row_get,     &
                              idx_first_col=idx_first_col, &
                              num_col_get=num_col_get,     &
                              values_imag=values_imag)
        return
    end subroutine Mat_Ptr_GetImagValues
#elif defined(ADAPTER_BLOCK_REAL)
    subroutine Mat_Ptr_SetValues(iA,            &
                                 idx_block_row, &
                                 idx_block_col, &
                                 idx_first_row, &
                                 num_row_set,   &
                                 idx_first_col, &
                                 num_col_set,   &
                                 values)
        use LANG_F_MODULE, only: Matrix_SetValues
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: idx_block_row
        integer(kind=QINT), intent(in) :: idx_block_col
        integer(kind=QINT), intent(in) :: idx_first_row
        integer(kind=QINT), intent(in) :: num_row_set
        integer(kind=QINT), intent(in) :: idx_first_col
        integer(kind=QINT), intent(in) :: num_col_set
        real(kind=QREAL), intent(in) :: values(num_row_set*num_col_set)
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_SetValues(A=A%f90_mat,                 &
                              idx_block_row=idx_block_row, &
                              idx_block_col=idx_block_col, &
                              idx_first_row=idx_first_row, &
                              num_row_set=num_row_set,     &
                              idx_first_col=idx_first_col, &
                              num_col_set=num_col_set,     &
                              values=values)
        return
    end subroutine Mat_Ptr_SetValues

    subroutine Mat_Ptr_AddValues(iA,            &
                                 idx_block_row, &
                                 idx_block_col, &
                                 idx_first_row, &
                                 num_row_add,   &
                                 idx_first_col, &
                                 num_col_add,   &
                                 values)
        use LANG_F_MODULE, only: Matrix_AddValues
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: idx_block_row
        integer(kind=QINT), intent(in) :: idx_block_col
        integer(kind=QINT), intent(in) :: idx_first_row
        integer(kind=QINT), intent(in) :: num_row_add
        integer(kind=QINT), intent(in) :: idx_first_col
        integer(kind=QINT), intent(in) :: num_col_add
        real(kind=QREAL), intent(in) :: values(num_row_add*num_col_add)
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_AddValues(A=A%f90_mat,                 &
                              idx_block_row=idx_block_row, &
                              idx_block_col=idx_block_col, &
                              idx_first_row=idx_first_row, &
                              num_row_add=num_row_add,     &
                              idx_first_col=idx_first_col, &
                              num_col_add=num_col_add,     &
                              values=values)
        return
    end subroutine Mat_Ptr_AddValues

    subroutine Mat_Ptr_GetValues(iA,            &
                                 idx_block_row, &
                                 idx_block_col, &
                                 idx_first_row, &
                                 num_row_get,   &
                                 idx_first_col, &
                                 num_col_get,   &
                                 values)
        use LANG_F_MODULE, only: Matrix_GetValues
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: idx_block_row
        integer(kind=QINT), intent(in) :: idx_block_col
        integer(kind=QINT), intent(in) :: idx_first_row
        integer(kind=QINT), intent(in) :: num_row_get
        integer(kind=QINT), intent(in) :: idx_first_col
        integer(kind=QINT), intent(in) :: num_col_get
        real(kind=QREAL), intent(out) :: values(num_row_get*num_col_get)
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_GetValues(A=A%f90_mat,                 &
                              idx_block_row=idx_block_row, &
                              idx_block_col=idx_block_col, &
                              idx_first_row=idx_first_row, &
                              num_row_get=num_row_get,     &
                              idx_first_col=idx_first_col, &
                              num_col_get=num_col_get,     &
                              values=values)
        return
    end subroutine Mat_Ptr_GetValues
#elif defined(ADAPTER_CMPLX_MAT)
    subroutine Mat_Ptr_SetRealValues(iA,            &
                                     idx_first_row, &
                                     num_row_set,   &
                                     idx_first_col, &
                                     num_col_set,   &
                                     values_real)
        use LANG_F_MODULE, only: Matrix_SetValues
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: idx_first_row
        integer(kind=QINT), intent(in) :: num_row_set
        integer(kind=QINT), intent(in) :: idx_first_col
        integer(kind=QINT), intent(in) :: num_col_set
        real(kind=QREAL), intent(in) :: values_real(num_row_set*num_col_set)
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_SetValues(A=A%f90_mat,                 &
                              idx_first_row=idx_first_row, &
                              num_row_set=num_row_set,     &
                              idx_first_col=idx_first_col, &
                              num_col_set=num_col_set,     &
                              values_real=values_real)
        return
    end subroutine Mat_Ptr_SetRealValues

    subroutine Mat_Ptr_SetImagValues(iA,            &
                                     idx_first_row, &
                                     num_row_set,   &
                                     idx_first_col, &
                                     num_col_set,   &
                                     values_imag)
        use LANG_F_MODULE, only: Matrix_SetValues
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: idx_first_row
        integer(kind=QINT), intent(in) :: num_row_set
        integer(kind=QINT), intent(in) :: idx_first_col
        integer(kind=QINT), intent(in) :: num_col_set
        real(kind=QREAL), intent(in) :: values_imag(num_row_set*num_col_set)
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_SetValues(A=A%f90_mat,                 &
                              idx_first_row=idx_first_row, &
                              num_row_set=num_row_set,     &
                              idx_first_col=idx_first_col, &
                              num_col_set=num_col_set,     &
                              values_imag=values_imag)
        return
    end subroutine Mat_Ptr_SetImagValues

    subroutine Mat_Ptr_AddRealValues(iA,            &
                                     idx_first_row, &
                                     num_row_add,   &
                                     idx_first_col, &
                                     num_col_add,   &
                                     values_real)
        use LANG_F_MODULE, only: Matrix_AddValues
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: idx_first_row
        integer(kind=QINT), intent(in) :: num_row_add
        integer(kind=QINT), intent(in) :: idx_first_col
        integer(kind=QINT), intent(in) :: num_col_add
        real(kind=QREAL), intent(in) :: values_real(num_row_add*num_col_add)
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_AddValues(A=A%f90_mat,                 &
                              idx_first_row=idx_first_row, &
                              num_row_add=num_row_add,     &
                              idx_first_col=idx_first_col, &
                              num_col_add=num_col_add,     &
                              values_real=values_real)
        return
    end subroutine Mat_Ptr_AddRealValues

    subroutine Mat_Ptr_AddImagValues(iA,            &
                                     idx_first_row, &
                                     num_row_add,   &
                                     idx_first_col, &
                                     num_col_add,   &
                                     values_imag)
        use LANG_F_MODULE, only: Matrix_AddValues
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: idx_first_row
        integer(kind=QINT), intent(in) :: num_row_add
        integer(kind=QINT), intent(in) :: idx_first_col
        integer(kind=QINT), intent(in) :: num_col_add
        real(kind=QREAL), intent(in) :: values_imag(num_row_add*num_col_add)
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_AddValues(A=A%f90_mat,                 &
                              idx_first_row=idx_first_row, &
                              num_row_add=num_row_add,     &
                              idx_first_col=idx_first_col, &
                              num_col_add=num_col_add,     &
                              values_imag=values_imag)
        return
    end subroutine Mat_Ptr_AddImagValues

    subroutine Mat_Ptr_GetRealValues(iA,            &
                                     idx_first_row, &
                                     num_row_get,   &
                                     idx_first_col, &
                                     num_col_get,   &
                                     values_real)
        use LANG_F_MODULE, only: Matrix_GetValues
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: idx_first_row
        integer(kind=QINT), intent(in) :: num_row_get
        integer(kind=QINT), intent(in) :: idx_first_col
        integer(kind=QINT), intent(in) :: num_col_get
        real(kind=QREAL), intent(out) :: values_real(num_row_get*num_col_get)
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_GetValues(A=A%f90_mat,                 &
                              idx_first_row=idx_first_row, &
                              num_row_get=num_row_get,     &
                              idx_first_col=idx_first_col, &
                              num_col_get=num_col_get,     &
                              values_real=values_real)
        return
    end subroutine Mat_Ptr_GetRealValues

    subroutine Mat_Ptr_GetImagValues(iA,            &
                                     idx_first_row, &
                                     num_row_get,   &
                                     idx_first_col, &
                                     num_col_get,   &
                                     values_imag)
        use LANG_F_MODULE, only: Matrix_GetValues
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: idx_first_row
        integer(kind=QINT), intent(in) :: num_row_get
        integer(kind=QINT), intent(in) :: idx_first_col
        integer(kind=QINT), intent(in) :: num_col_get
        real(kind=QREAL), intent(out) :: values_imag(num_row_get*num_col_get)
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_GetValues(A=A%f90_mat,                 &
                              idx_first_row=idx_first_row, &
                              num_row_get=num_row_get,     &
                              idx_first_col=idx_first_col, &
                              num_col_get=num_col_get,     &
                              values_imag=values_imag)
        return
    end subroutine Mat_Ptr_GetImagValues
#else
    subroutine Mat_Ptr_SetValues(iA,            &
                                 idx_first_row, &
                                 num_row_set,   &
                                 idx_first_col, &
                                 num_col_set,   &
                                 values)
        use LANG_F_MODULE, only: Matrix_SetValues
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: idx_first_row
        integer(kind=QINT), intent(in) :: num_row_set
        integer(kind=QINT), intent(in) :: idx_first_col
        integer(kind=QINT), intent(in) :: num_col_set
        real(kind=QREAL), intent(in) :: values(num_row_set*num_col_set)
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_SetValues(A=A%f90_mat,                 &
                              idx_first_row=idx_first_row, &
                              num_row_set=num_row_set,     &
                              idx_first_col=idx_first_col, &
                              num_col_set=num_col_set,     &
                              values=values)
        return
    end subroutine Mat_Ptr_SetValues

    subroutine Mat_Ptr_AddValues(iA,            &
                                 idx_first_row, &
                                 num_row_add,   &
                                 idx_first_col, &
                                 num_col_add,   &
                                 values)
        use LANG_F_MODULE, only: Matrix_AddValues
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: idx_first_row
        integer(kind=QINT), intent(in) :: num_row_add
        integer(kind=QINT), intent(in) :: idx_first_col
        integer(kind=QINT), intent(in) :: num_col_add
        real(kind=QREAL), intent(in) :: values(num_row_add*num_col_add)
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_AddValues(A=A%f90_mat,                 &
                              idx_first_row=idx_first_row, &
                              num_row_add=num_row_add,     &
                              idx_first_col=idx_first_col, &
                              num_col_add=num_col_add,     &
                              values=values)
        return
    end subroutine Mat_Ptr_AddValues

    subroutine Mat_Ptr_GetValues(iA,            &
                                 idx_first_row, &
                                 num_row_get,   &
                                 idx_first_col, &
                                 num_col_get,   &
                                 values)
        use LANG_F_MODULE, only: Matrix_GetValues
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: idx_first_row
        integer(kind=QINT), intent(in) :: num_row_get
        integer(kind=QINT), intent(in) :: idx_first_col
        integer(kind=QINT), intent(in) :: num_col_get
        real(kind=QREAL), intent(out) :: values(num_row_get*num_col_get)
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_GetValues(A=A%f90_mat,                 &
                              idx_first_row=idx_first_row, &
                              num_row_get=num_row_get,     &
                              idx_first_col=idx_first_col, &
                              num_col_get=num_col_get,     &
                              values=values)
        return
    end subroutine Mat_Ptr_GetValues
#endif

    subroutine Mat_Ptr_Duplicate(iA, duplicate_option, iB)
        use LANG_F_MODULE, only: Matrix_Duplicate
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: duplicate_option
        integer(kind=QINT), intent(in) :: iB(SIZEOF_F_TYPE_P)
        type(matrix_ptr_t) A
        type(matrix_ptr_t) B
        A = transfer(iA, A)
        B = transfer(iB, B)
        call Matrix_Duplicate(A%f90_mat, duplicate_option, B%f90_mat)
        return
    end subroutine Mat_Ptr_Duplicate

    subroutine Mat_Ptr_ZeroEntries(iA)
        use LANG_F_MODULE, only: Matrix_ZeroEntries
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_ZeroEntries(A%f90_mat)
        return
    end subroutine Mat_Ptr_ZeroEntries

#if defined(ADAPTER_BLOCK_CMPLX)
    subroutine Mat_Ptr_GetTrace(iA, num_blocks, trace)
        use LANG_F_MODULE, only: Matrix_GetTrace
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: num_blocks
        real(kind=QREAL), intent(out) :: trace(2*num_blocks)
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_GetTrace(A%f90_mat, num_blocks, trace)
        return
    end subroutine Mat_Ptr_GetTrace

    subroutine Mat_Ptr_GetMatProdTrace(iA, iB, op_B, num_blocks, trace)
        use LANG_F_MODULE, only: Matrix_GetMatProdTrace
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: iB(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: op_B
        integer(kind=QINT), intent(in) :: num_blocks
        real(kind=QREAL), intent(out) :: trace(2*num_blocks)
        type(matrix_ptr_t) A
        type(matrix_ptr_t) B
        A = transfer(iA, A)
        B = transfer(iB, B)
        call Matrix_GetMatProdTrace(A%f90_mat, B%f90_mat, op_B, num_blocks, trace)
        return
    end subroutine Mat_Ptr_GetMatProdTrace
#elif defined(ADAPTER_BLOCK_REAL)
    subroutine Mat_Ptr_GetTrace(iA, num_blocks, trace)
        use LANG_F_MODULE, only: Matrix_GetTrace
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: num_blocks
        real(kind=QREAL), intent(out) :: trace(num_blocks)
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_GetTrace(A%f90_mat, num_blocks, trace)
        return
    end subroutine Mat_Ptr_GetTrace

    subroutine Mat_Ptr_GetMatProdTrace(iA, iB, op_B, num_blocks, trace)
        use LANG_F_MODULE, only: Matrix_GetMatProdTrace
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: iB(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: op_B
        integer(kind=QINT), intent(in) :: num_blocks
        real(kind=QREAL), intent(out) :: trace(num_blocks)
        type(matrix_ptr_t) A
        type(matrix_ptr_t) B
        A = transfer(iA, A)
        B = transfer(iB, B)
        call Matrix_GetMatProdTrace(A%f90_mat, B%f90_mat, op_B, num_blocks, trace)
        return
    end subroutine Mat_Ptr_GetMatProdTrace
#elif defined(ADAPTER_CMPLX_MAT)
    subroutine Mat_Ptr_GetTrace(iA, trace)
        use LANG_F_MODULE, only: Matrix_GetTrace
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        real(kind=QREAL), intent(out) :: trace(2)
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_GetTrace(A%f90_mat, trace)
        return
    end subroutine Mat_Ptr_GetTrace

    subroutine Mat_Ptr_GetMatProdTrace(iA, iB, op_B, trace)
        use LANG_F_MODULE, only: Matrix_GetMatProdTrace
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: iB(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: op_B
        real(kind=QREAL), intent(out) :: trace(2)
        type(matrix_ptr_t) A
        type(matrix_ptr_t) B
        A = transfer(iA, A)
        B = transfer(iB, B)
        call Matrix_GetMatProdTrace(A%f90_mat, B%f90_mat, op_B, trace)
        return
    end subroutine Mat_Ptr_GetMatProdTrace
#else
    subroutine Mat_Ptr_GetTrace(iA, trace)
        use LANG_F_MODULE, only: Matrix_GetTrace
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        real(kind=QREAL), intent(out) :: trace
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_GetTrace(A%f90_mat, trace)
        return
    end subroutine Mat_Ptr_GetTrace

    subroutine Mat_Ptr_GetMatProdTrace(iA, iB, op_B, trace)
        use LANG_F_MODULE, only: Matrix_GetMatProdTrace
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: iB(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: op_B
        real(kind=QREAL), intent(out) :: trace
        type(matrix_ptr_t) A
        type(matrix_ptr_t) B
        A = transfer(iA, A)
        B = transfer(iB, B)
        call Matrix_GetMatProdTrace(A%f90_mat, B%f90_mat, op_B, trace)
        return
    end subroutine Mat_Ptr_GetMatProdTrace
#endif

#if defined(QCMATRIX_ENABLE_VIEW)
    subroutine Mat_Ptr_Write(iA, len_mat_label, mat_label, view_option)
        use LANG_F_MODULE, only: Matrix_Write
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: len_mat_label
        character*(*), intent(in) :: mat_label
        integer(kind=QINT), intent(in) :: view_option
        type(matrix_ptr_t) A
        character(len=len_mat_label) f_mat_label
        A = transfer(iA, A)
        f_mat_label = mat_label(1:len_mat_label)
        call Matrix_Write(A%f90_mat, f_mat_label, view_option)
        return
    end subroutine Mat_Ptr_Write
#endif

#if defined(QCMATRIX_ENABLE_VIEW)
    subroutine Mat_Ptr_Read(iA, len_mat_label, mat_label, view_option)
        use LANG_F_MODULE, only: Matrix_Read
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: len_mat_label
        character*(*), intent(in) :: mat_label
        integer(kind=QINT), intent(in) :: view_option
        type(matrix_ptr_t) A
        character(len=len_mat_label) f_mat_label
        A = transfer(iA, A)
        f_mat_label = mat_label(1:len_mat_label)
        call Matrix_Read(A%f90_mat, f_mat_label, view_option)
        return
    end subroutine Mat_Ptr_Read
#endif

#if defined(ADAPTER_BLOCK_CMPLX) || defined(ADAPTER_CMPLX_MAT)
    subroutine Mat_Ptr_Scale(scal_number, iA)
        use LANG_F_MODULE, only: Matrix_Scale
        implicit none
        real(kind=QREAL), intent(in) :: scal_number(2)
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_Scale(scal_number, A%f90_mat)
        return
    end subroutine Mat_Ptr_Scale
#else
    subroutine Mat_Ptr_Scale(scal_number, iA)
        use LANG_F_MODULE, only: Matrix_Scale
        implicit none
        real(kind=QREAL), intent(in) :: scal_number
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_Scale(scal_number, A%f90_mat)
        return
    end subroutine Mat_Ptr_Scale
#endif

#if defined(ADAPTER_BLOCK_CMPLX) || defined(ADAPTER_CMPLX_MAT)
    subroutine Mat_Ptr_AXPY(multiplier, iX, iY)
        use LANG_F_MODULE, only: Matrix_AXPY
        implicit none
        real(kind=QREAL), intent(in) :: multiplier(2)
        integer(kind=QINT), intent(in) :: iX(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: iY(SIZEOF_F_TYPE_P)
        type(matrix_ptr_t) X
        type(matrix_ptr_t) Y
        X = transfer(iX, X)
        Y = transfer(iY, Y)
        call Matrix_AXPY(multiplier, X%f90_mat, Y%f90_mat)
        return
    end subroutine Mat_Ptr_AXPY
#else
    subroutine Mat_Ptr_AXPY(multiplier, iX, iY)
        use LANG_F_MODULE, only: Matrix_AXPY
        implicit none
        real(kind=QREAL), intent(in) :: multiplier
        integer(kind=QINT), intent(in) :: iX(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: iY(SIZEOF_F_TYPE_P)
        type(matrix_ptr_t) X
        type(matrix_ptr_t) Y
        X = transfer(iX, X)
        Y = transfer(iY, Y)
        call Matrix_AXPY(multiplier, X%f90_mat, Y%f90_mat)
        return
    end subroutine Mat_Ptr_AXPY
#endif

    subroutine Mat_Ptr_Transpose(op_A, iA, iB)
        use LANG_F_MODULE, only: Matrix_Transpose
        implicit none
        integer(kind=QINT), intent(in) :: op_A
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: iB(SIZEOF_F_TYPE_P)
        type(matrix_ptr_t) A
        type(matrix_ptr_t) B
        A = transfer(iA, A)
        B = transfer(iB, B)
        call Matrix_Transpose(op_A, A%f90_mat, B%f90_mat)
        return
    end subroutine Mat_Ptr_Transpose

#if defined(ADAPTER_BLOCK_CMPLX) || defined(ADAPTER_CMPLX_MAT)
    subroutine Mat_Ptr_GEMM(op_A, op_B, alpha, iA, iB, beta, iC)
        use LANG_F_MODULE, only: Matrix_GEMM
        implicit none
        integer(kind=QINT), intent(in) :: op_A
        integer(kind=QINT), intent(in) :: op_B
        real(kind=QREAL), intent(in) :: alpha(2)
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: iB(SIZEOF_F_TYPE_P)
        real(kind=QREAL), intent(in) :: beta(2)
        integer(kind=QINT), intent(in) :: iC(SIZEOF_F_TYPE_P)
        type(matrix_ptr_t) A
        type(matrix_ptr_t) B
        type(matrix_ptr_t) C
        A = transfer(iA, A)
        B = transfer(iB, B)
        C = transfer(iC, C)
        call Matrix_GEMM(op_A, op_B, alpha, A%f90_mat, B%f90_mat, beta, C%f90_mat)
        return
    end subroutine Mat_Ptr_GEMM
#else
    subroutine Mat_Ptr_GEMM(op_A, op_B, alpha, iA, iB, beta, iC)
        use LANG_F_MODULE, only: Matrix_GEMM
        implicit none
        integer(kind=QINT), intent(in) :: op_A
        integer(kind=QINT), intent(in) :: op_B
        real(kind=QREAL), intent(in) :: alpha
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        integer(kind=QINT), intent(in) :: iB(SIZEOF_F_TYPE_P)
        real(kind=QREAL), intent(in) :: beta
        integer(kind=QINT), intent(in) :: iC(SIZEOF_F_TYPE_P)
        type(matrix_ptr_t) A
        type(matrix_ptr_t) B
        type(matrix_ptr_t) C
        A = transfer(iA, A)
        B = transfer(iB, B)
        C = transfer(iC, C)
        call Matrix_GEMM(op_A, op_B, alpha, A%f90_mat, B%f90_mat, beta, C%f90_mat)
        return
    end subroutine Mat_Ptr_GEMM
#endif

    subroutine Mat_Ptr_SetExternalMat(iA, A_ext)
        use LANG_F_MODULE, only: Matrix_Destroy
        implicit none
        integer(kind=QINT), intent(inout) :: iA(SIZEOF_F_TYPE_P)
        type(LANG_F_MATRIX), pointer, intent(in) :: A_ext
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        call Matrix_Destroy(A%f90_mat)
        deallocate(A%f90_mat)
        A%f90_mat => A_ext
        iA = transfer(A, iA)  !gets the new iA
        return
    end subroutine Mat_Ptr_SetExternalMat

    subroutine Mat_Ptr_GetExternalMat(iA, A_ext)
        implicit none
        integer(kind=QINT), intent(in) :: iA(SIZEOF_F_TYPE_P)
        type(LANG_F_MATRIX), pointer, intent(inout) :: A_ext
        type(matrix_ptr_t) A
        A = transfer(iA, A)
        A_ext => A%f90_mat
        return
    end subroutine Mat_Ptr_GetExternalMat

end module f90_adapter
