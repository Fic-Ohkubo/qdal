/*
   QcMatrix: an abstract matrix library
   Copyright 2012-2015 Bin Gao
   
   QcMatrix is free software: you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.
   
   QcMatrix is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU Lesser General Public License for more details.
   
   You should have received a copy of the GNU Lesser General Public License
   along with QcMatrix. If not, see <http://www.gnu.org/licenses/>.
   
   This file implements the functions in adapter/mat_adapter.h by calling
   src/adapter/f90_adapter_f.F90.
   
   2014-03-11, Bin Gao:
   * generated by tools/qcmatrix_fortran.py
*/

#include "adapter/mat_adapter.h"
/* uses CMake generated header file with auto-detected mangling */
#include "f90_mangling.h"

/* declaration of Fortran 90 subroutines */
extern QVoid f90_adapter_Mat_Ptr_Create(QInt *iA);
extern QVoid f90_adapter_Mat_Ptr_Destroy(QInt *iA);
#if defined(ADAPTER_BLOCK_CMPLX) || defined(ADAPTER_BLOCK_REAL)
extern QVoid f90_adapter_Mat_Ptr_BlockCreate(QInt *iA, const QInt *dim_block);
#endif
extern QVoid f90_adapter_Mat_Ptr_SetSymType(QInt *iA, const QInt *sym_type);
#if defined(ADAPTER_BLOCK_CMPLX)
extern QVoid f90_adapter_Mat_Ptr_SetDataType(QInt *iA,
                                             const QInt *num_blocks,
                                             const QInt *idx_block_row,
                                             const QInt *idx_block_col,
                                             const QInt *data_type);
#elif defined(ADAPTER_BLOCK_REAL)
extern QVoid f90_adapter_Mat_Ptr_SetNonZeroBlocks(QInt *iA,
                                                  const QInt *num_blocks,
                                                  const QInt *idx_block_row,
                                                  const QInt *idx_block_col);
#elif defined(ADAPTER_CMPLX_MAT)
extern QVoid f90_adapter_Mat_Ptr_SetDataType(QInt *iA, const QInt *data_type);
#endif
extern QVoid f90_adapter_Mat_Ptr_SetDimMat(QInt *iA,
                                           const QInt *num_row,
                                           const QInt *num_col);
#if defined(QCMATRIX_STORAGE_MODE)
extern QVoid f90_adapter_Mat_Ptr_SetStorageMode(QInt *iA, const QInt *storage_mode);
#endif
extern QVoid f90_adapter_Mat_Ptr_Assemble(QInt *iA);
#if defined(ADAPTER_BLOCK_CMPLX) || defined(ADAPTER_BLOCK_REAL)
extern QVoid f90_adapter_Mat_Ptr_GetDimBlock(QInt *iA, QInt *dim_block);
#endif
extern QVoid f90_adapter_Mat_Ptr_GetSymType(QInt *iA, QInt *sym_type);
#if defined(ADAPTER_BLOCK_CMPLX)
extern QVoid f90_adapter_Mat_Ptr_GetDataType(QInt *iA,
                                             const QInt *num_blocks,
                                             const QInt *idx_block_row,
                                             const QInt *idx_block_col,
                                             QInt *data_type);
#elif defined(ADAPTER_BLOCK_REAL)
extern QVoid f90_adapter_Mat_Ptr_GetNonZeroBlocks(QInt *iA,
                                                  const QInt *num_blocks,
                                                  const QInt *idx_block_row,
                                                  const QInt *idx_block_col,
                                                  QInt *is_non_zero);
#elif defined(ADAPTER_CMPLX_MAT)
extern QVoid f90_adapter_Mat_Ptr_GetDataType(QInt *iA, QInt *data_type);
#endif
extern QVoid f90_adapter_Mat_Ptr_GetDimMat(QInt *iA, QInt *num_row, QInt *num_col);
#if defined(QCMATRIX_STORAGE_MODE)
extern QVoid f90_adapter_Mat_Ptr_GetStorageMode(QInt *iA, QInt *storage_mode);
#endif
extern QVoid f90_adapter_Mat_Ptr_IsAssembled(QInt *iA, QInt *assembled);
#if defined(ADAPTER_BLOCK_CMPLX)
extern QVoid f90_adapter_Mat_Ptr_SetRealValues(QInt *iA,
                                               const QInt *idx_block_row,
                                               const QInt *idx_block_col,
                                               const QInt *idx_first_row,
                                               const QInt *num_row_set,
                                               const QInt *idx_first_col,
                                               const QInt *num_col_set,
                                               const QReal *values_real);
extern QVoid f90_adapter_Mat_Ptr_SetImagValues(QInt *iA,
                                               const QInt *idx_block_row,
                                               const QInt *idx_block_col,
                                               const QInt *idx_first_row,
                                               const QInt *num_row_set,
                                               const QInt *idx_first_col,
                                               const QInt *num_col_set,
                                               const QReal *values_imag);
extern QVoid f90_adapter_Mat_Ptr_AddRealValues(QInt *iA,
                                               const QInt *idx_block_row,
                                               const QInt *idx_block_col,
                                               const QInt *idx_first_row,
                                               const QInt *num_row_add,
                                               const QInt *idx_first_col,
                                               const QInt *num_col_add,
                                               const QReal *values_real);
extern QVoid f90_adapter_Mat_Ptr_AddImagValues(QInt *iA,
                                               const QInt *idx_block_row,
                                               const QInt *idx_block_col,
                                               const QInt *idx_first_row,
                                               const QInt *num_row_add,
                                               const QInt *idx_first_col,
                                               const QInt *num_col_add,
                                               const QReal *values_imag);
extern QVoid f90_adapter_Mat_Ptr_GetRealValues(QInt *iA,
                                               const QInt *idx_block_row,
                                               const QInt *idx_block_col,
                                               const QInt *idx_first_row,
                                               const QInt *num_row_get,
                                               const QInt *idx_first_col,
                                               const QInt *num_col_get,
                                               QReal *values_real);
extern QVoid f90_adapter_Mat_Ptr_GetImagValues(QInt *iA,
                                               const QInt *idx_block_row,
                                               const QInt *idx_block_col,
                                               const QInt *idx_first_row,
                                               const QInt *num_row_get,
                                               const QInt *idx_first_col,
                                               const QInt *num_col_get,
                                               QReal *values_imag);
#elif defined(ADAPTER_BLOCK_REAL)
extern QVoid f90_adapter_Mat_Ptr_SetValues(QInt *iA,
                                           const QInt *idx_block_row,
                                           const QInt *idx_block_col,
                                           const QInt *idx_first_row,
                                           const QInt *num_row_set,
                                           const QInt *idx_first_col,
                                           const QInt *num_col_set,
                                           const QReal *values);
extern QVoid f90_adapter_Mat_Ptr_AddValues(QInt *iA,
                                           const QInt *idx_block_row,
                                           const QInt *idx_block_col,
                                           const QInt *idx_first_row,
                                           const QInt *num_row_add,
                                           const QInt *idx_first_col,
                                           const QInt *num_col_add,
                                           const QReal *values);
extern QVoid f90_adapter_Mat_Ptr_GetValues(QInt *iA,
                                           const QInt *idx_block_row,
                                           const QInt *idx_block_col,
                                           const QInt *idx_first_row,
                                           const QInt *num_row_get,
                                           const QInt *idx_first_col,
                                           const QInt *num_col_get,
                                           QReal *values);
#elif defined(ADAPTER_CMPLX_MAT)
extern QVoid f90_adapter_Mat_Ptr_SetRealValues(QInt *iA,
                                               const QInt *idx_first_row,
                                               const QInt *num_row_set,
                                               const QInt *idx_first_col,
                                               const QInt *num_col_set,
                                               const QReal *values_real);
extern QVoid f90_adapter_Mat_Ptr_SetImagValues(QInt *iA,
                                               const QInt *idx_first_row,
                                               const QInt *num_row_set,
                                               const QInt *idx_first_col,
                                               const QInt *num_col_set,
                                               const QReal *values_imag);
extern QVoid f90_adapter_Mat_Ptr_AddRealValues(QInt *iA,
                                               const QInt *idx_first_row,
                                               const QInt *num_row_add,
                                               const QInt *idx_first_col,
                                               const QInt *num_col_add,
                                               const QReal *values_real);
extern QVoid f90_adapter_Mat_Ptr_AddImagValues(QInt *iA,
                                               const QInt *idx_first_row,
                                               const QInt *num_row_add,
                                               const QInt *idx_first_col,
                                               const QInt *num_col_add,
                                               const QReal *values_imag);
extern QVoid f90_adapter_Mat_Ptr_GetRealValues(QInt *iA,
                                               const QInt *idx_first_row,
                                               const QInt *num_row_get,
                                               const QInt *idx_first_col,
                                               const QInt *num_col_get,
                                               QReal *values_real);
extern QVoid f90_adapter_Mat_Ptr_GetImagValues(QInt *iA,
                                               const QInt *idx_first_row,
                                               const QInt *num_row_get,
                                               const QInt *idx_first_col,
                                               const QInt *num_col_get,
                                               QReal *values_imag);
#else
extern QVoid f90_adapter_Mat_Ptr_SetValues(QInt *iA,
                                           const QInt *idx_first_row,
                                           const QInt *num_row_set,
                                           const QInt *idx_first_col,
                                           const QInt *num_col_set,
                                           const QReal *values);
extern QVoid f90_adapter_Mat_Ptr_AddValues(QInt *iA,
                                           const QInt *idx_first_row,
                                           const QInt *num_row_add,
                                           const QInt *idx_first_col,
                                           const QInt *num_col_add,
                                           const QReal *values);
extern QVoid f90_adapter_Mat_Ptr_GetValues(QInt *iA,
                                           const QInt *idx_first_row,
                                           const QInt *num_row_get,
                                           const QInt *idx_first_col,
                                           const QInt *num_col_get,
                                           QReal *values);
#endif
extern QVoid f90_adapter_Mat_Ptr_Duplicate(QInt *iA,
                                           const QInt *duplicate_option,
                                           QInt *iB);
extern QVoid f90_adapter_Mat_Ptr_ZeroEntries(QInt *iA);
#if defined(ADAPTER_BLOCK_CMPLX)
extern QVoid f90_adapter_Mat_Ptr_GetTrace(QInt *iA,
                                          const QInt *num_blocks,
                                          QReal *trace);
extern QVoid f90_adapter_Mat_Ptr_GetMatProdTrace(QInt *iA,
                                                 QInt *iB,
                                                 const QInt *op_B,
                                                 const QInt *num_blocks,
                                                 QReal *trace);
#elif defined(ADAPTER_BLOCK_REAL)
extern QVoid f90_adapter_Mat_Ptr_GetTrace(QInt *iA,
                                          const QInt *num_blocks,
                                          QReal *trace);
extern QVoid f90_adapter_Mat_Ptr_GetMatProdTrace(QInt *iA,
                                                 QInt *iB,
                                                 const QInt *op_B,
                                                 const QInt *num_blocks,
                                                 QReal *trace);
#elif defined(ADAPTER_CMPLX_MAT)
extern QVoid f90_adapter_Mat_Ptr_GetTrace(QInt *iA, QReal *trace);
extern QVoid f90_adapter_Mat_Ptr_GetMatProdTrace(QInt *iA,
                                                 QInt *iB,
                                                 const QInt *op_B,
                                                 QReal *trace);
#else
extern QVoid f90_adapter_Mat_Ptr_GetTrace(QInt *iA, QReal *trace);
extern QVoid f90_adapter_Mat_Ptr_GetMatProdTrace(QInt *iA,
                                                 QInt *iB,
                                                 const QInt *op_B,
                                                 QReal *trace);
#endif
#if defined(QCMATRIX_ENABLE_VIEW)
extern QVoid f90_adapter_Mat_Ptr_Write(QInt *iA,
                                       const QInt *len_mat_label,
                                       const QChar *mat_label,
                                       const QInt *view_option);
#endif
#if defined(QCMATRIX_ENABLE_VIEW)
extern QVoid f90_adapter_Mat_Ptr_Read(QInt *iA,
                                      const QInt *len_mat_label,
                                      const QChar *mat_label,
                                      const QInt *view_option);
#endif
#if defined(ADAPTER_BLOCK_CMPLX) || defined(ADAPTER_CMPLX_MAT)
extern QVoid f90_adapter_Mat_Ptr_Scale(const QReal *scal_number, QInt *iA);
#else
extern QVoid f90_adapter_Mat_Ptr_Scale(const QReal *scal_number, QInt *iA);
#endif
#if defined(ADAPTER_BLOCK_CMPLX) || defined(ADAPTER_CMPLX_MAT)
extern QVoid f90_adapter_Mat_Ptr_AXPY(const QReal *multiplier, QInt *iX, QInt *iY);
#else
extern QVoid f90_adapter_Mat_Ptr_AXPY(const QReal *multiplier, QInt *iX, QInt *iY);
#endif
extern QVoid f90_adapter_Mat_Ptr_Transpose(const QInt *op_A, QInt *iA, QInt *iB);
#if defined(ADAPTER_BLOCK_CMPLX) || defined(ADAPTER_CMPLX_MAT)
extern QVoid f90_adapter_Mat_Ptr_GEMM(const QInt *op_A,
                                      const QInt *op_B,
                                      const QReal *alpha,
                                      QInt *iA,
                                      QInt *iB,
                                      const QReal *beta,
                                      QInt *iC);
#else
extern QVoid f90_adapter_Mat_Ptr_GEMM(const QInt *op_A,
                                      const QInt *op_B,
                                      const QReal *alpha,
                                      QInt *iA,
                                      QInt *iB,
                                      const QReal *beta,
                                      QInt *iC);
#endif

QErrorCode AdapterMatCreate(AdapterMat *A)
{
    f90_adapter_Mat_Ptr_Create(&A->f90_imat[0]);
    A->external_mat = QFALSE;
    return QSUCCESS;
}

QErrorCode AdapterMatDestroy(AdapterMat *A)
{
    if (A->external_mat==QFALSE) {
        f90_adapter_Mat_Ptr_Destroy(&A->f90_imat[0]);
    }
    return QSUCCESS;
}

#if defined(ADAPTER_BLOCK_CMPLX) || defined(ADAPTER_BLOCK_REAL)
QErrorCode AdapterMatBlockCreate(AdapterMat *A, const QInt dim_block)
{
    f90_adapter_Mat_Ptr_BlockCreate(&A->f90_imat[0], &dim_block);
    return QSUCCESS;
}
#endif

QErrorCode AdapterMatSetSymType(AdapterMat *A, const QcSymType sym_type)
{
    /* converts symmetry types, to be consistent with
       include/api/qcmatrix_f_mat_symmetry.h90 and include/types/mat_symmetry.h */
    QInt def_sym_type[3]={-1,0,1};
    f90_adapter_Mat_Ptr_SetSymType(&A->f90_imat[0], &def_sym_type[sym_type+1]);
    return QSUCCESS;
}

#if defined(ADAPTER_BLOCK_CMPLX)
QErrorCode AdapterMatSetDataType(AdapterMat *A,
                                 const QInt num_blocks,
                                 const QInt idx_block_row[],
                                 const QInt idx_block_col[],
                                 const QcDataType data_type[])
{
    /* defined data types, to be consistent with
       include/api/qcmatrix_f_mat_data.h90 and include/types/mat_data.h */
    QInt def_data_type[4]={-1,0,1,2};
    QInt *f_data_type;
    QInt iblk;
    f_data_type = (QInt *)malloc(num_blocks*sizeof(QInt));
    if (f_data_type==NULL) {
        QErrorExit(FILE_AND_LINE, "failed to allocate memory for f_data_type");
    }
    for (iblk=0; iblk<num_blocks; iblk++) {
        f_data_type[iblk] = def_data_type[data_type[iblk]+1];
    }
    f90_adapter_Mat_Ptr_SetDataType(&A->f90_imat[0],
                                    &num_blocks,
                                    idx_block_row,
                                    idx_block_col,
                                    f_data_type);
    free(f_data_type);
    f_data_type = NULL;
    return QSUCCESS;
}
#elif defined(ADAPTER_BLOCK_REAL)
QErrorCode AdapterMatSetNonZeroBlocks(AdapterMat *A,
                                      const QInt num_blocks,
                                      const QInt idx_block_row[],
                                      const QInt idx_block_col[])
{
    f90_adapter_Mat_Ptr_SetNonZeroBlocks(&A->f90_imat[0],
                                         &num_blocks,
                                         idx_block_row,
                                         idx_block_col);
    return QSUCCESS;
}
#elif defined(ADAPTER_CMPLX_MAT)
QErrorCode AdapterMatSetDataType(Mat *A, const QcDataType data_type)
{
    /* defined data types, to be consistent with
       include/api/qcmatrix_f_mat_data.h90 and include/types/mat_data.h */
    QInt def_data_type[4]={-1,0,1,2};
    f90_adapter_Mat_Ptr_SetDataType(&A->f90_imat[0], &def_data_type[data_type+1]);
    return QSUCCESS;
}
#endif

QErrorCode AdapterMatSetDimMat(AdapterMat *A, const QInt num_row, const QInt num_col)
{
    f90_adapter_Mat_Ptr_SetDimMat(&A->f90_imat[0], &num_row, &num_col);
    return QSUCCESS;
}

#if defined(QCMATRIX_STORAGE_MODE)
/* FIXME: converts QcStorageMode to QInt */
QErrorCode AdapterMatSetStorageMode(AdapterMat *A, const QcStorageMode storage_mode)
{
    f90_adapter_Mat_Ptr_SetStorageMode(&A->f90_imat[0], &storage_mode);
    return QSUCCESS;
}
#endif

QErrorCode AdapterMatAssemble(AdapterMat *A)
{
    f90_adapter_Mat_Ptr_Assemble(&A->f90_imat[0]);
    return QSUCCESS;
}

#if defined(ADAPTER_BLOCK_CMPLX) || defined(ADAPTER_BLOCK_REAL)
QErrorCode AdapterMatGetDimBlock(AdapterMat *A, QInt *dim_block)
{
    f90_adapter_Mat_Ptr_GetDimBlock(&A->f90_imat[0], dim_block);
    return QSUCCESS;
}
#endif

QErrorCode AdapterMatGetSymType(AdapterMat *A, QcSymType *sym_type)
{
    /* defined symmetry types, to be consistent with include/api/qcmatrix_f_mat_symmetry.h90 */
    QcSymType def_sym_type[3]={QANTISYMMAT,QNONSYMMAT,QSYMMAT};
    QInt f_sym_type;
    f90_adapter_Mat_Ptr_GetSymType(&A->f90_imat[0], &f_sym_type);
    *sym_type = def_sym_type[f_sym_type+1];
    return QSUCCESS;
}

#if defined(ADAPTER_BLOCK_CMPLX)
QErrorCode AdapterMatGetDataType(AdapterMat *A,
                                 const QInt num_blocks,
                                 const QInt idx_block_row[],
                                 const QInt idx_block_col[],
                                 QcDataType *data_type)
{
    /* defined data types, to be consistent with include/api/qcmatrix_f_mat_data.h90 */
    QcDataType def_data_type[4]={QIMAGMAT,QCMPLXMAT,QREALMAT,QNULLMAT};
    QInt *f_data_type;
    QInt iblk;
    f_data_type = (QInt *)malloc(num_blocks*sizeof(QInt));
    if (f_data_type==NULL) {
        QErrorExit(FILE_AND_LINE, "failed to allocate memory for f_data_type");
    }
    f90_adapter_Mat_Ptr_GetDataType(&A->f90_imat[0],
                                    &num_blocks,
                                    idx_block_row,
                                    idx_block_col,
                                    f_data_type);
    for (iblk=0; iblk<num_blocks; iblk++) {
        data_type[iblk] = def_data_type[f_data_type[iblk]+1];
    }
    free(f_data_type);
    f_data_type = NULL;
    return QSUCCESS;
}
#elif defined(ADAPTER_BLOCK_REAL)
QErrorCode AdapterMatGetNonZeroBlocks(AdapterMat *A,
                                      const QInt num_blocks,
                                      const QInt idx_block_row[],
                                      const QInt idx_block_col[],
                                      QBool *is_non_zero)
{
    /* Boolean type, to be consistent with
       include/api/qcmatrix_f_boolean.h90 and include/types/qcmatrix_basic_types.h */
    QBool c_Boolean[2]={QFALSE,QTRUE};
    QInt *f_is_non_zero;
    f_is_non_zero = (QInt *)malloc(num_blocks*sizeof(QInt));
    if (f_is_non_zero==NULL) {
        QErrorExit(FILE_AND_LINE, "failed to allocate memory for f_is_non_zero");
    }
    f90_adapter_Mat_Ptr_GetNonZeroBlocks(&A->f90_imat[0],
                                         &num_blocks,
                                         idx_block_row,
                                         idx_block_col,
                                         f_is_non_zero);
    for (iblk=0; iblk<num_blocks; iblk++) {
        is_non_zero[iblk] = c_Boolean[f_is_non_zero[iblk]];
    }
    free(f_is_non_zero);
    f_is_non_zero = NULL;
    return QSUCCESS;
}
#elif defined(ADAPTER_CMPLX_MAT)
QErrorCode AdapterMatGetDataType(AdapterMat *A, QcDataType *data_type)
{
    /* defined data types, to be consistent with include/api/qcmatrix_f_mat_data.h90 */
    QcDataType def_data_type[4]={QIMAGMAT,QCMPLXMAT,QREALMAT,QNULLMAT};
    QInt f_data_type;
    f90_adapter_Mat_Ptr_GetDataType(&A->f90_imat[0], &f_data_type);
    *data_type = def_data_type[f_data_type+1];
    return QSUCCESS;
}
#endif

QErrorCode AdapterMatGetDimMat(AdapterMat *A, QInt *num_row, QInt *num_col)
{
    f90_adapter_Mat_Ptr_GetDimMat(&A->f90_imat[0], num_row, num_col);
    return QSUCCESS;
}

#if defined(QCMATRIX_STORAGE_MODE)
/* FIXME: converts QcStorageMode to QInt */
QErrorCode AdapterMatGetStorageMode(AdapterMat *A, QcStorageMode *storage_mode)
{
    f90_adapter_Mat_Ptr_GetStorageMode(&A->f90_imat[0], storage_mode);
    return QSUCCESS;
}
#endif

QErrorCode AdapterMatIsAssembled(AdapterMat *A, QBool *assembled)
{
    /* Boolean type, to be consistent with
       include/api/qcmatrix_f_boolean.h90 and include/types/qcmatrix_basic_types.h */
    QBool c_Boolean[2]={QFALSE,QTRUE};
    QInt f_assembled;
    f90_adapter_Mat_Ptr_IsAssembled(&A->f90_imat[0], &f_assembled);
    *assembled = c_Boolean[f_assembled];
    return QSUCCESS;
}

#if defined(ADAPTER_BLOCK_CMPLX)
QErrorCode AdapterMatSetValues(AdapterMat *A,
                               const QInt idx_block_row,
                               const QInt idx_block_col,
                               const QInt idx_first_row,
                               const QInt num_row_set,
                               const QInt idx_first_col,
                               const QInt num_col_set,
                               const QReal *values_real,
                               const QReal *values_imag)
{
    if (values_real!=NULL) {
        f90_adapter_Mat_Ptr_SetRealValues(&A->f90_imat[0],
                                          &idx_block_row,
                                          &idx_block_col,
                                          &idx_first_row,
                                          &num_row_set,
                                          &idx_first_col,
                                          &num_col_set,
                                          values_real);
    }
    if (values_imag!=NULL) {
        f90_adapter_Mat_Ptr_SetImagValues(&A->f90_imat[0],
                                          &idx_block_row,
                                          &idx_block_col,
                                          &idx_first_row,
                                          &num_row_set,
                                          &idx_first_col,
                                          &num_col_set,
                                          values_imag);
    }
    return QSUCCESS;
}

QErrorCode AdapterMatAddValues(AdapterMat *A,
                               const QInt idx_block_row,
                               const QInt idx_block_col,
                               const QInt idx_first_row,
                               const QInt num_row_add,
                               const QInt idx_first_col,
                               const QInt num_col_add,
                               const QReal *values_real,
                               const QReal *values_imag)
{
    if (values_real!=NULL) {
        f90_adapter_Mat_Ptr_AddRealValues(&A->f90_imat[0],
                                          &idx_block_row,
                                          &idx_block_col,
                                          &idx_first_row,
                                          &num_row_add,
                                          &idx_first_col,
                                          &num_col_add,
                                          values_real);
    }
    if (values_imag!=NULL) {
        f90_adapter_Mat_Ptr_AddImagValues(&A->f90_imat[0],
                                          &idx_block_row,
                                          &idx_block_col,
                                          &idx_first_row,
                                          &num_row_add,
                                          &idx_first_col,
                                          &num_col_add,
                                          values_imag);
    }
    return QSUCCESS;
}

QErrorCode AdapterMatGetValues(AdapterMat *A,
                               const QInt idx_block_row,
                               const QInt idx_block_col,
                               const QInt idx_first_row,
                               const QInt num_row_get,
                               const QInt idx_first_col,
                               const QInt num_col_get,
                               QReal *values_real,
                               QReal *values_imag)
{
    if (values_real!=NULL) {
        f90_adapter_Mat_Ptr_GetRealValues(&A->f90_imat[0],
                                          &idx_block_row,
                                          &idx_block_col,
                                          &idx_first_row,
                                          &num_row_get,
                                          &idx_first_col,
                                          &num_col_get,
                                          values_real);
    }
    if (values_imag!=NULL) {
        f90_adapter_Mat_Ptr_GetImagValues(&A->f90_imat[0],
                                          &idx_block_row,
                                          &idx_block_col,
                                          &idx_first_row,
                                          &num_row_get,
                                          &idx_first_col,
                                          &num_col_get,
                                          values_imag);
    }
    return QSUCCESS;              
}
#elif defined(ADAPTER_BLOCK_REAL)
QErrorCode AdapterMatSetValues(AdapterMat *A,
                               const QInt idx_block_row,
                               const QInt idx_block_col,
                               const QInt idx_first_row,
                               const QInt num_row_set,
                               const QInt idx_first_col,
                               const QInt num_col_set,
                               const QReal *values)
{
    f90_adapter_Mat_Ptr_SetValues(&A->f90_imat[0],
                                  &idx_block_row,
                                  &idx_block_col,
                                  &idx_first_row,
                                  &num_row_set,
                                  &idx_first_col,
                                  &num_col_set,
                                  values);
    return QSUCCESS;
}

QErrorCode AdapterMatAddValues(AdapterMat *A,
                               const QInt idx_block_row,
                               const QInt idx_block_col,
                               const QInt idx_first_row,
                               const QInt num_row_add,
                               const QInt idx_first_col,
                               const QInt num_col_add,
                               const QReal *values)
{
    f90_adapter_Mat_Ptr_AddValues(&A->f90_imat[0],
                                  &idx_block_row,
                                  &idx_block_col,
                                  &idx_first_row,
                                  &num_row_add,
                                  &idx_first_col,
                                  &num_col_add,
                                  values);
    return QSUCCESS;
}

QErrorCode AdapterMatGetValues(AdapterMat *A,
                               const QInt idx_block_row,
                               const QInt idx_block_col,
                               const QInt idx_first_row,
                               const QInt num_row_get,
                               const QInt idx_first_col,
                               const QInt num_col_get,
                               QReal *values)
{
    f90_adapter_Mat_Ptr_GetValues(&A->f90_imat[0],
                                  &idx_block_row,
                                  &idx_block_col,
                                  &idx_first_row,
                                  &num_row_get,
                                  &idx_first_col,
                                  &num_col_get,
                                  values);
    return QSUCCESS;
}
#elif defined(ADAPTER_CMPLX_MAT)
QErrorCode AdapterMatSetValues(AdapterMat *A,
                               const QInt idx_first_row,
                               const QInt num_row_set,
                               const QInt idx_first_col,
                               const QInt num_col_set,
                               const QReal *values_real,
                               const QReal *values_imag)
{
    if (values_real!=NULL) {
        f90_adapter_Mat_Ptr_SetRealValues(&A->f90_imat[0],
                                          &idx_first_row,
                                          &num_row_set,
                                          &idx_first_col,
                                          &num_col_set,
                                          values_real);
    }
    if (values_imag!=NULL) {
        f90_adapter_Mat_Ptr_SetImagValues(&A->f90_imat[0],
                                          &idx_first_row,
                                          &num_row_set,
                                          &idx_first_col,
                                          &num_col_set,
                                          values_imag);
    }
    return QSUCCESS;
}

QErrorCode AdapterMatAddValues(AdapterMat *A,
                               const QInt idx_first_row,
                               const QInt num_row_add,
                               const QInt idx_first_col,
                               const QInt num_col_add,
                               const QReal *values_real,
                               const QReal *values_imag)
{
    if (values_real!=NULL) {
        f90_adapter_Mat_Ptr_AddRealValues(&A->f90_imat[0],
                                          &idx_first_row,
                                          &num_row_add,
                                          &idx_first_col,
                                          &num_col_add,
                                          values_real);
    }
    if (values_imag!=NULL) {
        f90_adapter_Mat_Ptr_AddImagValues(&A->f90_imat[0],
                                          &idx_first_row,
                                          &num_row_add,
                                          &idx_first_col,
                                          &num_col_add,
                                          values_imag);
    }
    return QSUCCESS;
}

QErrorCode AdapterMatGetValues(AdapterMat *A,
                               const QInt idx_first_row,
                               const QInt num_row_get,
                               const QInt idx_first_col,
                               const QInt num_col_get,
                               QReal *values_real,
                               QReal *values_imag)
{
    if (values_real!=NULL) {
        f90_adapter_Mat_Ptr_GetRealValues(&A->f90_imat[0],
                                          &idx_first_row,
                                          &num_row_get,
                                          &idx_first_col,
                                          &num_col_get,
                                          values_real);
    }
    if (values_imag!=NULL) {
        f90_adapter_Mat_Ptr_GetImagValues(&A->f90_imat[0],
                                          &idx_first_row,
                                          &num_row_get,
                                          &idx_first_col,
                                          &num_col_get,
                                          values_imag);
    }
    return QSUCCESS;
}
#else
QErrorCode AdapterMatSetValues(AdapterMat *A,
                               const QInt idx_first_row,
                               const QInt num_row_set,
                               const QInt idx_first_col,
                               const QInt num_col_set,
                               const QReal *values)
{
    f90_adapter_Mat_Ptr_SetValues(&A->f90_imat[0],
                                  &idx_first_row,
                                  &num_row_set,
                                  &idx_first_col,
                                  &num_col_set,
                                  values);
    return QSUCCESS;
}

QErrorCode AdapterMatAddValues(AdapterMat *A,
                               const QInt idx_first_row,
                               const QInt num_row_add,
                               const QInt idx_first_col,
                               const QInt num_col_add,
                               const QReal *values)
{
    f90_adapter_Mat_Ptr_AddValues(&A->f90_imat[0],
                                  &idx_first_row,
                                  &num_row_add,
                                  &idx_first_col,
                                  &num_col_add,
                                  values);
    return QSUCCESS;
}

QErrorCode AdapterMatGetValues(AdapterMat *A,
                               const QInt idx_first_row,
                               const QInt num_row_get,
                               const QInt idx_first_col,
                               const QInt num_col_get,
                               QReal *values)
{
    f90_adapter_Mat_Ptr_GetValues(&A->f90_imat[0],
                                  &idx_first_row,
                                  &num_row_get,
                                  &idx_first_col,
                                  &num_col_get,
                                  values);
    return QSUCCESS;
}
#endif

QErrorCode AdapterMatDuplicate(AdapterMat *A,
                               const QcDuplicateOption duplicate_option,
                               AdapterMat *B)
{
    /* defined duplicate option, to be consistent with
       include/api/qcmatrix_f_mat_duplicate.h90 and include/types/mat_duplicate.h */
    QInt def_dup_option[2]={0,1};
    f90_adapter_Mat_Ptr_Duplicate(&A->f90_imat[0],
                                  &def_dup_option[duplicate_option],
                                  &B->f90_imat[0]);
    return QSUCCESS;
}

QErrorCode AdapterMatZeroEntries(AdapterMat *A)
{
    f90_adapter_Mat_Ptr_ZeroEntries(&A->f90_imat[0]);
    return QSUCCESS;
}

#if defined(ADAPTER_BLOCK_CMPLX)
QErrorCode AdapterMatGetTrace(AdapterMat *A, const QInt num_blocks, QReal *trace)
{
    f90_adapter_Mat_Ptr_GetTrace(&A->f90_imat[0], &num_blocks, trace);
    return QSUCCESS;
}

QErrorCode AdapterMatGetMatProdTrace(AdapterMat *A,
                                     AdapterMat *B,
                                     const QcMatOperation op_B,
                                     const QInt num_blocks,
                                     QReal *trace)
{
    /* defined operations on the matrix, to be consistent with
       include/api/qcmatrix_f_mat_operations.h90 and include/types/mat_operations.h */
    QInt def_mat_op[4]={0,1,2,3};
    f90_adapter_Mat_Ptr_GetMatProdTrace(&A->f90_imat[0],
                                        &B->f90_imat[0],
                                        &def_mat_op[op_B],
                                        &num_blocks,
                                        trace);
    return QSUCCESS;
}
#elif defined(ADAPTER_BLOCK_REAL)
QErrorCode AdapterMatGetTrace(AdapterMat *A, const QInt num_blocks, QReal *trace)
{
    f90_adapter_Mat_Ptr_GetTrace(&A->f90_imat[0], &num_blocks, trace);
    return QSUCCESS;
}

QErrorCode AdapterMatGetMatProdTrace(AdapterMat *A,
                                     AdapterMat *B,
                                     const QcMatOperation op_B,
                                     const QInt num_blocks,
                                     QReal *trace)
{
    /* defined operations on the matrix, to be consistent with
       include/api/qcmatrix_f_mat_operations.h90 and include/types/mat_operations.h */
    QInt def_mat_op[4]={0,1,2,3};
    f90_adapter_Mat_Ptr_GetMatProdTrace(&A->f90_imat[0],
                                        &B->f90_imat[0],
                                        &def_mat_op[op_B],
                                        &num_blocks,
                                        trace);
    return QSUCCESS;
}
#elif defined(ADAPTER_CMPLX_MAT)
QErrorCode AdapterMatGetTrace(AdapterMat *A, QReal *trace)
{
    f90_adapter_Mat_Ptr_GetTrace(&A->f90_imat[0], trace);
    return QSUCCESS;
}

QErrorCode AdapterMatGetMatProdTrace(AdapterMat *A,
                                     AdapterMat *B,
                                     const QcMatOperation op_B,
                                     QReal *trace)
{
    /* defined operations on the matrix, to be consistent with
       include/api/qcmatrix_f_mat_operations.h90 and include/types/mat_operations.h */
    QInt def_mat_op[4]={0,1,2,3};
    f90_adapter_Mat_Ptr_GetMatProdTrace(&A->f90_imat[0],
                                        &B->f90_imat[0],
                                        &def_mat_op[op_B],
                                        trace);
    return QSUCCESS;
}
#else
QErrorCode AdapterMatGetTrace(AdapterMat *A, QReal *trace)
{
    f90_adapter_Mat_Ptr_GetTrace(&A->f90_imat[0], trace);
    return QSUCCESS;
}

QErrorCode AdapterMatGetMatProdTrace(AdapterMat *A,
                                     AdapterMat *B,
                                     const QcMatOperation op_B,
                                     QReal *trace)
{
    /* defined operations on the matrix, to be consistent with
       include/api/qcmatrix_f_mat_operations.h90 and include/types/mat_operations.h */
    QInt def_mat_op[4]={0,1,2,3};
    f90_adapter_Mat_Ptr_GetMatProdTrace(&A->f90_imat[0],
                                        &B->f90_imat[0],
                                        &def_mat_op[op_B],
                                        trace);
    return QSUCCESS;
}
#endif

#if defined(QCMATRIX_ENABLE_VIEW)
QErrorCode AdapterMatWrite(AdapterMat *A,
                           const QChar *mat_label,
                           const QcViewOption view_option)
{
    /* defined view option, to be consistend with
       include/api/qcmatrix_f_mat_view.h90 and include/types/mat_view.h */
    QInt def_view_option[2]={0,1};
    QInt len_mat_label = strlen(mat_label);
    f90_adapter_Mat_Ptr_Write(&A->f90_imat[0],
                              &len_mat_label,
                              mat_label,
                              &def_view_option[view_option]);
    return QSUCCESS;
}

QErrorCode AdapterMatRead(AdapterMat *A,
                          const QChar *mat_label,
                          const QcViewOption view_option)
{
    /* defined view option, to be consistend with
       include/api/qcmatrix_f_mat_view.h90 and include/types/mat_view.h */
    QInt def_view_option[2]={0,1};
    QInt len_mat_label = strlen(mat_label);
    f90_adapter_Mat_Ptr_Read(&A->f90_imat[0],
                             &len_mat_label,
                             mat_label, 
                             &def_view_option[view_option]);
    return QSUCCESS;
}
#endif

#if defined(ADAPTER_BLOCK_CMPLX) || defined(ADAPTER_CMPLX_MAT)
QErrorCode AdapterMatScale(const QReal scal_number[], AdapterMat *A)
{
    f90_adapter_Mat_Ptr_Scale(scal_number, &A->f90_imat[0]);
    return QSUCCESS;
}
#else
QErrorCode AdapterMatScale(const QReal scal_number, AdapterMat *A)
{
    f90_adapter_Mat_Ptr_Scale(&scal_number, &A->f90_imat[0]);
    return QSUCCESS;
}
#endif

#if defined(ADAPTER_BLOCK_CMPLX) || defined(ADAPTER_CMPLX_MAT)
QErrorCode AdapterMatAXPY(const QReal multiplier[], AdapterMat *X, AdapterMat *Y)
{
    f90_adapter_Mat_Ptr_AXPY(multiplier, &X->f90_imat[0], &Y->f90_imat[0]);
    return QSUCCESS;
}
#else
QErrorCode AdapterMatAXPY(const QReal multiplier, AdapterMat *X, AdapterMat *Y)
{
    f90_adapter_Mat_Ptr_AXPY(&multiplier, &X->f90_imat[0], &Y->f90_imat[0]);
    return QSUCCESS;
}
#endif

QErrorCode AdapterMatTranspose(const QcMatOperation op_A, AdapterMat *A, AdapterMat *B)
{
    /* defined operations on the matrix, to be consistent with
       include/api/qcmatrix_f_mat_operations.h90 and include/types/mat_operations.h */
    QInt def_mat_op[4]={0,1,2,3};
    f90_adapter_Mat_Ptr_Transpose(&def_mat_op[op_A], &A->f90_imat[0], &B->f90_imat[0]);
    return QSUCCESS;
}

#if defined(ADAPTER_BLOCK_CMPLX) || defined(ADAPTER_CMPLX_MAT)
QErrorCode AdapterMatGEMM(const QcMatOperation op_A,
                          const QcMatOperation op_B,
                          const QReal alpha[],
                          AdapterMat *A,
                          AdapterMat *B,
                          const QReal beta[],
                          AdapterMat *C)
{
    /* defined operations on the matrix, to be consistent with
       include/api/qcmatrix_f_mat_operations.h90 and include/types/mat_operations.h */
    QInt def_mat_op[4]={0,1,2,3};
    f90_adapter_Mat_Ptr_GEMM(&def_mat_op[op_A],
                             &def_mat_op[op_B],
                             alpha,
                             &A->f90_imat[0],
                             &B->f90_imat[0],
                             beta,
                             &C->f90_imat[0]);
    return QSUCCESS;
}
#else
QErrorCode AdapterMatGEMM(const QcMatOperation op_A,
                          const QcMatOperation op_B,
                          const QReal alpha,
                          AdapterMat *A,
                          AdapterMat *B,
                          const QReal beta,
                          AdapterMat *C)
{
    /* defined operations on the matrix, to be consistent with
       include/api/qcmatrix_f_mat_operations.h90 and include/types/mat_operations.h */
    QInt def_mat_op[4]={0,1,2,3};
    f90_adapter_Mat_Ptr_GEMM(&def_mat_op[op_A],
                             &def_mat_op[op_B],
                             &alpha,
                             &A->f90_imat[0],
                             &B->f90_imat[0],
                             &beta,
                             &C->f90_imat[0]);
    return QSUCCESS;
}
#endif

QErrorCode AdapterMatSetExternalMat(AdapterMat *A, QInt *iA)
{
    QInt ibyt;
    for (ibyt=0; ibyt<SIZEOF_F_TYPE_P; ibyt++) {
        A->f90_imat[ibyt] = iA[ibyt];
    }
    A->external_mat = QTRUE;
    return QSUCCESS;
}

QErrorCode AdapterMatGetExternalMat(AdapterMat *A, QInt *iA)
{
    QInt ibyt;
    for (ibyt=0; ibyt<SIZEOF_F_TYPE_P; ibyt++) {
        iA[ibyt] = A->f90_imat[ibyt];
    }
    return QSUCCESS;
}
