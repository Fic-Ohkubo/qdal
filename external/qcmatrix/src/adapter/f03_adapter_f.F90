!!  QcMatrix: an abstract matrix library
!!  Copyright 2012-2015 Bin Gao
!!
!!  QcMatrix is free software: you can redistribute it and/or modify
!!  it under the terms of the GNU Lesser General Public License as published by
!!  the Free Software Foundation, either version 3 of the License, or
!!  (at your option) any later version.
!!
!!  QcMatrix is distributed in the hope that it will be useful,
!!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
!!  GNU Lesser General Public License for more details.
!!
!!  You should have received a copy of the GNU Lesser General Public License
!!  along with QcMatrix. If not, see <http://www.gnu.org/licenses/>.
!!
!!  This file provides an adapter between QcMatrix and external Fortran 2003
!!  matrix library.
!!
!!  2014-03-11, Bin Gao:
!!  * generated by tools/qcmatrix_fortran.py

! checks if the external Fortran module and matrix type are given
#include "adapter/check_f_mod.h"

! data types between C/Fortran
#include "api/qcmatrix_c_type.h"

subroutine Mat_Ptr_Create(A) bind(C, name="Mat_Ptr_Create")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_Create
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(out) :: A
    type(LANG_F_MATRIX), pointer :: f_A
    allocate(f_A)
    call Matrix_Create(f_A)
    A = c_loc(f_A)
    return
end subroutine Mat_Ptr_Create

subroutine Mat_Ptr_Destroy(A) bind(C, name="Mat_Ptr_Destroy")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_Destroy
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(inout) :: A
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_Destroy(f_A)
    deallocate(f_A)
    nullify(f_A)
    A = C_NULL_PTR
    return
end subroutine Mat_Ptr_Destroy

#if defined(ADAPTER_BLOCK_CMPLX) || defined(ADAPTER_BLOCK_REAL)
subroutine Mat_Ptr_BlockCreate(A, dim_block) bind(C, name="Mat_Ptr_BlockCreate")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_BlockCreate
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: dim_block
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_BlockCreate(f_A, dim_block)
    return
end subroutine Mat_Ptr_BlockCreate
#endif

subroutine Mat_Ptr_SetSymType(A, sym_type) bind(C, name="Mat_Ptr_SetSymType")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_SetSymType
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: sym_type
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_SetSymType(f_A, sym_type)
    return
end subroutine Mat_Ptr_SetSymType

#if defined(ADAPTER_BLOCK_CMPLX)
subroutine Mat_Ptr_SetDataType(A, num_blocks, idx_block_row, idx_block_col, data_type) &
    bind(C, name="Mat_Ptr_SetDataType")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_SetDataType
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: num_blocks
    integer(kind=C_QINT), intent(in) :: idx_block_row(num_blocks)
    integer(kind=C_QINT), intent(in) :: idx_block_col(num_blocks)
    integer(kind=C_QINT), intent(in) :: data_type(num_blocks)
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_SetDataType(f_A, num_blocks, idx_block_row, idx_block_col, data_type)
    return
end subroutine Mat_Ptr_SetDataType
#elif defined(ADAPTER_BLOCK_REAL)
subroutine Mat_Ptr_SetNonZeroBlocks(A, num_blocks, idx_block_row, idx_block_col) &
    bind(C, name="Mat_Ptr_SetNonZeroBlocks")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_SetNonZeroBlocks
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: num_blocks
    integer(kind=C_QINT), intent(in) :: idx_block_row(num_blocks)
    integer(kind=C_QINT), intent(in) :: idx_block_col(num_blocks)
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_SetNonZeroBlocks(f_A, num_blocks, idx_block_row, idx_block_col)
    return
end subroutine Mat_Ptr_SetNonZeroBlocks
#elif defined(ADAPTER_CMPLX_MAT)
subroutine Mat_Ptr_SetDataType(A, data_type) bind(C, name="Mat_Ptr_SetDataType")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_SetDataType
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: data_type
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_SetDataType(f_A, data_type)
    return
end subroutine Mat_Ptr_SetDataType
#endif

subroutine Mat_Ptr_SetDimMat(A, num_row, num_col) bind(C, name="Mat_Ptr_SetDimMat")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_SetDimMat
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: num_row
    integer(kind=C_QINT), value, intent(in) :: num_col
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_SetDimMat(f_A, num_row, num_col)
    return
end subroutine Mat_Ptr_SetDimMat

#if defined(QCMATRIX_STORAGE_MODE)
subroutine Mat_Ptr_SetStorageMode(A, storage_mode) bind(C, name="Mat_Ptr_SetStorageMode")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_SetStorageMode
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: storage_mode
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_SetStorageMode(f_A, storage_mode)
    return
end subroutine Mat_Ptr_SetStorageMode
#endif

subroutine Mat_Ptr_Assemble(A) bind(C, name="Mat_Ptr_Assemble")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_Assemble
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_Assemble(f_A)
    return
end subroutine Mat_Ptr_Assemble

#if defined(ADAPTER_BLOCK_CMPLX) || defined(ADAPTER_BLOCK_REAL)
subroutine Mat_Ptr_GetDimBlock(A, dim_block) bind(C, name="Mat_Ptr_GetDimBlock")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_GetDimBlock
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), intent(out) :: dim_block
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_GetDimBlock(f_A, dim_block)
    return
end subroutine Mat_Ptr_GetDimBlock
#endif

subroutine Mat_Ptr_GetSymType(A, sym_type) bind(C, name="Mat_Ptr_GetSymType")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_GetSymType
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), intent(out) :: sym_type
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_GetSymType(f_A, sym_type)
    return
end subroutine Mat_Ptr_GetSymType

#if defined(ADAPTER_BLOCK_CMPLX)
subroutine Mat_Ptr_GetDataType(A, num_blocks, idx_block_row, idx_block_col, data_type) &
    bind(C, name="Mat_Ptr_GetDataType")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_GetDataType
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: num_blocks
    integer(kind=C_QINT), intent(in) :: idx_block_row(num_blocks)
    integer(kind=C_QINT), intent(in) :: idx_block_col(num_blocks)
    integer(kind=C_QINT), intent(out) :: data_type(num_blocks)
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_GetDataType(f_A, num_blocks, idx_block_row, idx_block_col, data_type)
    return
end subroutine Mat_Ptr_GetDataType
#elif defined(ADAPTER_BLOCK_REAL)
subroutine Mat_Ptr_GetNonZeroBlocks(A,             &
                                    num_blocks,    &
                                    idx_block_row, &
                                    idx_block_col, &
                                    is_non_zero)      &
    bind(C, name="Mat_Ptr_GetNonZeroBlocks")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_GetNonZeroBlocks
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: num_blocks
    integer(kind=C_QINT), intent(in) :: idx_block_row(num_blocks)
    integer(kind=C_QINT), intent(in) :: idx_block_col(num_blocks)
    integer(kind=C_QINT), intent(out) :: is_non_zero(num_blocks)
    type(LANG_F_MATRIX), pointer :: f_A
#include "api/qcmatrix_f_boolean.h90"
    logical(kind=4), pointer :: f_is_non_zero(:)
    integer(kind=C_QINT) iblk
    call c_f_pointer(A, f_A)
    allocate(f_is_non_zero(num_blocks))
    call Matrix_GetNonZeroBlocks(f_A,           &
                                 num_blocks,    &
                                 idx_block_row, &
                                 idx_block_col, &
                                 f_is_non_zero)
    do iblk = 1, num_blocks
        if (f_is_non_zero(iblk)) then
            is_non_zero(iblk) = QTRUE
        else
            is_non_zero(iblk) = QFALSE
        end if
    end do
    deallocate(f_is_non_zero)
    nullify(f_is_non_zero)
    return
end subroutine Mat_Ptr_GetNonZeroBlocks
#elif defined(ADAPTER_CMPLX_MAT)
subroutine Mat_Ptr_GetDataType(A, data_type) bind(C, name="Mat_Ptr_GetDataType")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_GetDataType
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), intent(out) :: data_type
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_GetDataType(f_A, data_type)
    return
end subroutine Mat_Ptr_GetDataType
#endif

subroutine Mat_Ptr_GetDimMat(A, num_row, num_col) bind(C, name="Mat_Ptr_GetDimMat")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_GetDimMat
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), intent(out) :: num_row
    integer(kind=C_QINT), intent(out) :: num_col
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_GetDimMat(f_A, num_row, num_col)
    return
end subroutine Mat_Ptr_GetDimMat

#if defined(QCMATRIX_STORAGE_MODE)
subroutine Mat_Ptr_GetStorageMode(A, storage_mode) bind(C, name="Mat_Ptr_GetStorageMode")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_GetStorageMode
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), intent(out) :: storage_mode
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_GetStorageMode(f_A, storage_mode)
    return
end subroutine Mat_Ptr_GetStorageMode
#endif

subroutine Mat_Ptr_IsAssembled(A, assembled) bind(C, name="Mat_Ptr_IsAssembled")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_IsAssembled
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), intent(out) :: assembled
    type(LANG_F_MATRIX), pointer :: f_A
#include "api/qcmatrix_f_boolean.h90"
    logical(kind=4) f_assembled
    call c_f_pointer(A, f_A)
    call Matrix_IsAssembled(f_A, f_assembled)
    if (f_assembled) then
        assembled = QTRUE
    else
        assembled = QFALSE
    end if
    return
end subroutine Mat_Ptr_IsAssembled

#if defined(ADAPTER_BLOCK_CMPLX)
subroutine Mat_Ptr_SetRealValues(A,             &
                                 idx_block_row, &
                                 idx_block_col, &
                                 idx_first_row, &
                                 num_row_set,   &
                                 idx_first_col, &
                                 num_col_set,   &
                                 values_real)   &
    bind(C, name="Mat_Ptr_SetRealValues")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_SetValues
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: idx_block_row
    integer(kind=C_QINT), value, intent(in) :: idx_block_col
    integer(kind=C_QINT), value, intent(in) :: idx_first_row
    integer(kind=C_QINT), value, intent(in) :: num_row_set
    integer(kind=C_QINT), value, intent(in) :: idx_first_col
    integer(kind=C_QINT), value, intent(in) :: num_col_set
    real(kind=C_QREAL), intent(in) :: values_real(num_row_set*num_col_set)
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_SetValues(A=f_A,                       &
                          idx_block_row=idx_block_row, &
                          idx_block_col=idx_block_col, &
                          idx_first_row=idx_first_row, &
                          num_row_set=num_row_set,     &
                          idx_first_col=idx_first_col, &
                          num_col_set=num_col_set,     &
                          values_real=values_real)
    return
end subroutine Mat_Ptr_SetRealValues

subroutine Mat_Ptr_SetImagValues(A,             &
                                 idx_block_row, &
                                 idx_block_col, &
                                 idx_first_row, &
                                 num_row_set,   &
                                 idx_first_col, &
                                 num_col_set,   &
                                 values_imag)   &
    bind(C, name="Mat_Ptr_SetImagValues")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_SetValues
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: idx_block_row
    integer(kind=C_QINT), value, intent(in) :: idx_block_col
    integer(kind=C_QINT), value, intent(in) :: idx_first_row
    integer(kind=C_QINT), value, intent(in) :: num_row_set
    integer(kind=C_QINT), value, intent(in) :: idx_first_col
    integer(kind=C_QINT), value, intent(in) :: num_col_set
    real(kind=C_QREAL), intent(in) :: values_imag(num_row_set*num_col_set)
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_SetValues(A=f_A,                       &
                          idx_block_row=idx_block_row, &
                          idx_block_col=idx_block_col, &
                          idx_first_row=idx_first_row, &
                          num_row_set=num_row_set,     &
                          idx_first_col=idx_first_col, &
                          num_col_set=num_col_set,     &
                          values_imag=values_imag)
    return
end subroutine Mat_Ptr_SetImagValues

subroutine Mat_Ptr_AddRealValues(A,             &
                                 idx_block_row, &
                                 idx_block_col, &
                                 idx_first_row, &
                                 num_row_add,   &
                                 idx_first_col, &
                                 num_col_add,   &
                                 values_real)   &
    bind(C, name="Mat_Ptr_AddRealValues")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_AddValues
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: idx_block_row
    integer(kind=C_QINT), value, intent(in) :: idx_block_col
    integer(kind=C_QINT), value, intent(in) :: idx_first_row
    integer(kind=C_QINT), value, intent(in) :: num_row_add
    integer(kind=C_QINT), value, intent(in) :: idx_first_col
    integer(kind=C_QINT), value, intent(in) :: num_col_add
    real(kind=C_QREAL), intent(in) :: values_real(num_row_add*num_col_add)
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_AddValues(A=f_A,                       &
                          idx_block_row=idx_block_row, &
                          idx_block_col=idx_block_col, &
                          idx_first_row=idx_first_row, &
                          num_row_add=num_row_add,     &
                          idx_first_col=idx_first_col, &
                          num_col_add=num_col_add,     &
                          values_real=values_real)
    return
end subroutine Mat_Ptr_AddRealValues

subroutine Mat_Ptr_AddImagValues(A,             &
                                 idx_block_row, &
                                 idx_block_col, &
                                 idx_first_row, &
                                 num_row_add,   &
                                 idx_first_col, &
                                 num_col_add,   &
                                 values_imag)   &
    bind(C, name="Mat_Ptr_AddImagValues")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_AddValues
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: idx_block_row
    integer(kind=C_QINT), value, intent(in) :: idx_block_col
    integer(kind=C_QINT), value, intent(in) :: idx_first_row
    integer(kind=C_QINT), value, intent(in) :: num_row_add
    integer(kind=C_QINT), value, intent(in) :: idx_first_col
    integer(kind=C_QINT), value, intent(in) :: num_col_add
    real(kind=C_QREAL), intent(in) :: values_imag(num_row_add*num_col_add)
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_AddValues(A=f_A,                       &
                          idx_block_row=idx_block_row, &
                          idx_block_col=idx_block_col, &
                          idx_first_row=idx_first_row, &
                          num_row_add=num_row_add,     &
                          idx_first_col=idx_first_col, &
                          num_col_add=num_col_add,     &
                          values_imag=values_imag)
    return
end subroutine Mat_Ptr_AddImagValues

subroutine Mat_Ptr_GetRealValues(A,             &
                                 idx_block_row, &
                                 idx_block_col, &
                                 idx_first_row, &
                                 num_row_get,   &
                                 idx_first_col, &
                                 num_col_get,   &
                                 values_real)   &
    bind(C, name="Mat_Ptr_GetRealValues")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_GetValues
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: idx_block_row
    integer(kind=C_QINT), value, intent(in) :: idx_block_col
    integer(kind=C_QINT), value, intent(in) :: idx_first_row
    integer(kind=C_QINT), value, intent(in) :: num_row_get
    integer(kind=C_QINT), value, intent(in) :: idx_first_col
    integer(kind=C_QINT), value, intent(in) :: num_col_get
    real(kind=C_QREAL), intent(out) :: values_real(num_row_get*num_col_get)
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_GetValues(A=f_A,                       &
                          idx_block_row=idx_block_row, &
                          idx_block_col=idx_block_col, &
                          idx_first_row=idx_first_row, &
                          num_row_get=num_row_get,     &
                          idx_first_col=idx_first_col, &
                          num_col_get=num_col_get,     &
                          values_real=values_real)
    return
end subroutine Mat_Ptr_GetRealValues

subroutine Mat_Ptr_GetImagValues(A,             &
                                 idx_block_row, &
                                 idx_block_col, &
                                 idx_first_row, &
                                 num_row_get,   &
                                 idx_first_col, &
                                 num_col_get,   &
                                 values_imag)   &
    bind(C, name="Mat_Ptr_GetImagValues")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_GetValues
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: idx_block_row
    integer(kind=C_QINT), value, intent(in) :: idx_block_col
    integer(kind=C_QINT), value, intent(in) :: idx_first_row
    integer(kind=C_QINT), value, intent(in) :: num_row_get
    integer(kind=C_QINT), value, intent(in) :: idx_first_col
    integer(kind=C_QINT), value, intent(in) :: num_col_get
    real(kind=C_QREAL), intent(out) :: values_imag(num_row_get*num_col_get)
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_GetValues(A=f_A,                       &
                          idx_block_row=idx_block_row, &
                          idx_block_col=idx_block_col, &
                          idx_first_row=idx_first_row, &
                          num_row_get=num_row_get,     &
                          idx_first_col=idx_first_col, &
                          num_col_get=num_col_get,     &
                          values_imag=values_imag)
    return
end subroutine Mat_Ptr_GetImagValues
#elif defined(ADAPTER_BLOCK_REAL)
subroutine Mat_Ptr_SetValues(A,             &
                             idx_block_row, &
                             idx_block_col, &
                             idx_first_row, &
                             num_row_set,   &
                             idx_first_col, &
                             num_col_set,   &
                             values)        &
    bind(C, name="Mat_Ptr_SetValues")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_SetValues
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: idx_block_row
    integer(kind=C_QINT), value, intent(in) :: idx_block_col
    integer(kind=C_QINT), value, intent(in) :: idx_first_row
    integer(kind=C_QINT), value, intent(in) :: num_row_set
    integer(kind=C_QINT), value, intent(in) :: idx_first_col
    integer(kind=C_QINT), value, intent(in) :: num_col_set
    real(kind=C_QREAL), intent(in) :: values(num_row_set*num_col_set)
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_SetValues(A=f_A,                       &
                          idx_block_row=idx_block_row, &
                          idx_block_col=idx_block_col, &
                          idx_first_row=idx_first_row, &
                          num_row_set=num_row_set,     &
                          idx_first_col=idx_first_col, &
                          num_col_set=num_col_set,     &
                          values=values)
    return
end subroutine Mat_Ptr_SetValues

subroutine Mat_Ptr_AddValues(A,             &
                             idx_block_row, &
                             idx_block_col, &
                             idx_first_row, &
                             num_row_add,   &
                             idx_first_col, &
                             num_col_add,   &
                             values)        &
    bind(C, name="Mat_Ptr_AddValues")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_AddValues
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: idx_block_row
    integer(kind=C_QINT), value, intent(in) :: idx_block_col
    integer(kind=C_QINT), value, intent(in) :: idx_first_row
    integer(kind=C_QINT), value, intent(in) :: num_row_add
    integer(kind=C_QINT), value, intent(in) :: idx_first_col
    integer(kind=C_QINT), value, intent(in) :: num_col_add
    real(kind=C_QREAL), intent(in) :: values(num_row_add*num_col_add)
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_AddValues(A=f_A,                       &
                          idx_block_row=idx_block_row, &
                          idx_block_col=idx_block_col, &
                          idx_first_row=idx_first_row, &
                          num_row_add=num_row_add,     &
                          idx_first_col=idx_first_col, &
                          num_col_add=num_col_add,     &
                          values=values)
    return
end subroutine Mat_Ptr_AddValues

subroutine Mat_Ptr_GetValues(A,             &
                             idx_block_row, &
                             idx_block_col, &
                             idx_first_row, &
                             num_row_get,   &
                             idx_first_col, &
                             num_col_get,   &
                             values)        &
    bind(C, name="Mat_Ptr_GetValues")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_GetValues
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: idx_block_row
    integer(kind=C_QINT), value, intent(in) :: idx_block_col
    integer(kind=C_QINT), value, intent(in) :: idx_first_row
    integer(kind=C_QINT), value, intent(in) :: num_row_get
    integer(kind=C_QINT), value, intent(in) :: idx_first_col
    integer(kind=C_QINT), value, intent(in) :: num_col_get
    real(kind=C_QREAL), intent(out) :: values(num_row_get*num_col_get)
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_GetValues(A=f_A,                       &
                          idx_block_row=idx_block_row, &
                          idx_block_col=idx_block_col, &
                          idx_first_row=idx_first_row, &
                          num_row_get=num_row_get,     &
                          idx_first_col=idx_first_col, &
                          num_col_get=num_col_get,     &
                          values=values)
    return
end subroutine Mat_Ptr_GetValues
#elif defined(ADAPTER_CMPLX_MAT)
subroutine Mat_Ptr_SetRealValues(A,             &
                                 idx_first_row, &
                                 num_row_set,   &
                                 idx_first_col, &
                                 num_col_set,   &
                                 values_real)   &
    bind(C, name="Mat_Ptr_SetRealValues")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_SetValues
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: idx_first_row
    integer(kind=C_QINT), value, intent(in) :: num_row_set
    integer(kind=C_QINT), value, intent(in) :: idx_first_col
    integer(kind=C_QINT), value, intent(in) :: num_col_set
    real(kind=C_QREAL), intent(in) :: values_real(num_row_set*num_col_set)
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_SetValues(A=f_A,                       &
                          idx_first_row=idx_first_row, &
                          num_row_set=num_row_set,     &
                          idx_first_col=idx_first_col, &
                          num_col_set=num_col_set,     &
                          values_real=values_real)
    return
end subroutine Mat_Ptr_SetRealValues

subroutine Mat_Ptr_SetImagValues(A,             &
                                 idx_first_row, &
                                 num_row_set,   &
                                 idx_first_col, &
                                 num_col_set,   &
                                 values_imag)   &
    bind(C, name="Mat_Ptr_SetImagValues")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_SetValues
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: idx_first_row
    integer(kind=C_QINT), value, intent(in) :: num_row_set
    integer(kind=C_QINT), value, intent(in) :: idx_first_col
    integer(kind=C_QINT), value, intent(in) :: num_col_set
    real(kind=C_QREAL), intent(in) :: values_imag(num_row_set*num_col_set)
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_SetValues(A=f_A,                       &
                          idx_first_row=idx_first_row, &
                          num_row_set=num_row_set,     &
                          idx_first_col=idx_first_col, &
                          num_col_set=num_col_set,     &
                          values_imag=values_imag)
    return
end subroutine Mat_Ptr_SetImagValues

subroutine Mat_Ptr_AddRealValues(A,             &
                                 idx_first_row, &
                                 num_row_add,   &
                                 idx_first_col, &
                                 num_col_add,   &
                                 values_real)   &
    bind(C, name="Mat_Ptr_AddRealValues")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_AddValues
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: idx_first_row
    integer(kind=C_QINT), value, intent(in) :: num_row_add
    integer(kind=C_QINT), value, intent(in) :: idx_first_col
    integer(kind=C_QINT), value, intent(in) :: num_col_add
    real(kind=C_QREAL), intent(in) :: values_real(num_row_add*num_col_add)
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_AddValues(A=f_A,                       &
                          idx_first_row=idx_first_row, &
                          num_row_add=num_row_add,     &
                          idx_first_col=idx_first_col, &
                          num_col_add=num_col_add,     &
                          values_real=values_real)
    return
end subroutine Mat_Ptr_AddRealValues

subroutine Mat_Ptr_AddImagValues(A,             &
                                 idx_first_row, &
                                 num_row_add,   &
                                 idx_first_col, &
                                 num_col_add,   &
                                 values_imag)   &
    bind(C, name="Mat_Ptr_AddImagValues")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_AddValues
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: idx_first_row
    integer(kind=C_QINT), value, intent(in) :: num_row_add
    integer(kind=C_QINT), value, intent(in) :: idx_first_col
    integer(kind=C_QINT), value, intent(in) :: num_col_add
    real(kind=C_QREAL), intent(in) :: values_imag(num_row_add*num_col_add)
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_AddValues(A=f_A,                       &
                          idx_first_row=idx_first_row, &
                          num_row_add=num_row_add,     &
                          idx_first_col=idx_first_col, &
                          num_col_add=num_col_add,     &
                          values_imag=values_imag)
    return
end subroutine Mat_Ptr_AddImagValues

subroutine Mat_Ptr_GetRealValues(A,             &
                                 idx_first_row, &
                                 num_row_get,   &
                                 idx_first_col, &
                                 num_col_get,   &
                                 values_real)   &
    bind(C, name="Mat_Ptr_GetRealValues")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_GetValues
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: idx_first_row
    integer(kind=C_QINT), value, intent(in) :: num_row_get
    integer(kind=C_QINT), value, intent(in) :: idx_first_col
    integer(kind=C_QINT), value, intent(in) :: num_col_get
    real(kind=C_QREAL), intent(out) :: values_real(num_row_get*num_col_get)
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_GetValues(A=f_A,                       &
                          idx_first_row=idx_first_row, &
                          num_row_get=num_row_get,     &
                          idx_first_col=idx_first_col, &
                          num_col_get=num_col_get,     &
                          values_real=values_real)
    return
end subroutine Mat_Ptr_GetRealValues

subroutine Mat_Ptr_GetImagValues(A,             &
                                 idx_first_row, &
                                 num_row_get,   &
                                 idx_first_col, &
                                 num_col_get,   &
                                 values_imag)   &
    bind(C, name="Mat_Ptr_GetImagValues")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_GetValues
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: idx_first_row
    integer(kind=C_QINT), value, intent(in) :: num_row_get
    integer(kind=C_QINT), value, intent(in) :: idx_first_col
    integer(kind=C_QINT), value, intent(in) :: num_col_get
    real(kind=C_QREAL), intent(out) :: values_imag(num_row_get*num_col_get)
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_GetValues(A=f_A,                       &
                          idx_first_row=idx_first_row, &
                          num_row_get=num_row_get,     &
                          idx_first_col=idx_first_col, &
                          num_col_get=num_col_get,     &
                          values_imag=values_imag)
    return
end subroutine Mat_Ptr_GetImagValues
#else
subroutine Mat_Ptr_SetValues(A,             &
                             idx_first_row, &
                             num_row_set,   &
                             idx_first_col, &
                             num_col_set,   &
                             values)        &
    bind(C, name="Mat_Ptr_SetValues")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_SetValues
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: idx_first_row
    integer(kind=C_QINT), value, intent(in) :: num_row_set
    integer(kind=C_QINT), value, intent(in) :: idx_first_col
    integer(kind=C_QINT), value, intent(in) :: num_col_set
    real(kind=C_QREAL), intent(in) :: values(num_row_set*num_col_set)
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_SetValues(A=f_A,                       &
                          idx_first_row=idx_first_row, &
                          num_row_set=num_row_set,     &
                          idx_first_col=idx_first_col, &
                          num_col_set=num_col_set,     &
                          values=values)
    return
end subroutine Mat_Ptr_SetValues

subroutine Mat_Ptr_AddValues(A,             &
                             idx_first_row, &
                             num_row_add,   &
                             idx_first_col, &
                             num_col_add,   &
                             values)        &
    bind(C, name="Mat_Ptr_AddValues")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_AddValues
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: idx_first_row
    integer(kind=C_QINT), value, intent(in) :: num_row_add
    integer(kind=C_QINT), value, intent(in) :: idx_first_col
    integer(kind=C_QINT), value, intent(in) :: num_col_add
    real(kind=C_QREAL), intent(in) :: values(num_row_add*num_col_add)
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_AddValues(A=f_A,                       &
                          idx_first_row=idx_first_row, &
                          num_row_add=num_row_add,     &
                          idx_first_col=idx_first_col, &
                          num_col_add=num_col_add,     &
                          values=values)
    return
end subroutine Mat_Ptr_AddValues

subroutine Mat_Ptr_GetValues(A,             &
                             idx_first_row, &
                             num_row_get,   &
                             idx_first_col, &
                             num_col_get,   &
                             values)        &
    bind(C, name="Mat_Ptr_GetValues")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_GetValues
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: idx_first_row
    integer(kind=C_QINT), value, intent(in) :: num_row_get
    integer(kind=C_QINT), value, intent(in) :: idx_first_col
    integer(kind=C_QINT), value, intent(in) :: num_col_get
    real(kind=C_QREAL), intent(out) :: values(num_row_get*num_col_get)
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_GetValues(A=f_A,                       &
                          idx_first_row=idx_first_row, &
                          num_row_get=num_row_get,     &
                          idx_first_col=idx_first_col, &
                          num_col_get=num_col_get,     &
                          values=values)
    return
end subroutine Mat_Ptr_GetValues
#endif

subroutine Mat_Ptr_Duplicate(A, duplicate_option, B) bind(C, name="Mat_Ptr_Duplicate")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_Duplicate
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: duplicate_option
    type(C_PTR), intent(in) :: B
    type(LANG_F_MATRIX), pointer :: f_A
    type(LANG_F_MATRIX), pointer :: f_B
    call c_f_pointer(A, f_A)
    call c_f_pointer(B, f_B)
    call Matrix_Duplicate(f_A, duplicate_option, f_B)
    return
end subroutine Mat_Ptr_Duplicate

subroutine Mat_Ptr_ZeroEntries(A) bind(C, name="Mat_Ptr_ZeroEntries")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_ZeroEntries
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_ZeroEntries(f_A)
    return
end subroutine Mat_Ptr_ZeroEntries

#if defined(ADAPTER_BLOCK_CMPLX)
subroutine Mat_Ptr_GetTrace(A, num_blocks, trace) bind(C, name="Mat_Ptr_GetTrace")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_GetTrace
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: num_blocks
    real(kind=C_QREAL), intent(out) :: trace(2*num_blocks)
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_GetTrace(f_A, num_blocks, trace)
    return
end subroutine Mat_Ptr_GetTrace

subroutine Mat_Ptr_GetMatProdTrace(A, B, op_B, num_blocks, trace) &
    bind(C, name="Mat_Ptr_GetMatProdTrace")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_GetMatProdTrace
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    type(C_PTR), intent(in) :: B
    integer(kind=C_QINT), value, intent(in) :: op_B
    integer(kind=C_QINT), value, intent(in) :: num_blocks
    real(kind=C_QREAL), intent(out) :: trace(2*num_blocks)
    type(LANG_F_MATRIX), pointer :: f_A
    type(LANG_F_MATRIX), pointer :: f_B
    call c_f_pointer(A, f_A)
    call c_f_pointer(B, f_B)
    call Matrix_GetMatProdTrace(f_A, f_B, op_B, num_blocks, trace)
    return
end subroutine Mat_Ptr_GetMatProdTrace
#elif defined(ADAPTER_BLOCK_REAL)
subroutine Mat_Ptr_GetTrace(A, num_blocks, trace) bind(C, name="Mat_Ptr_GetTrace")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_GetTrace
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: num_blocks
    real(kind=C_QREAL), intent(out) :: trace(num_blocks)
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_GetTrace(f_A, num_blocks, trace)
    return
end subroutine Mat_Ptr_GetTrace

subroutine Mat_Ptr_GetMatProdTrace(A, B, op_B, num_blocks, trace) &
    bind(C, name="Mat_Ptr_GetMatProdTrace")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_GetMatProdTrace
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    type(C_PTR), intent(in) :: B
    integer(kind=C_QINT), value, intent(in) :: op_B
    integer(kind=C_QINT), value, intent(in) :: num_blocks
    real(kind=C_QREAL), intent(out) :: trace(num_blocks)
    type(LANG_F_MATRIX), pointer :: f_A
    type(LANG_F_MATRIX), pointer :: f_B
    call c_f_pointer(A, f_A)
    call c_f_pointer(B, f_B)
    call Matrix_GetMatProdTrace(f_A, f_B, op_B, num_blocks, trace)
    return
end subroutine Mat_Ptr_GetMatProdTrace
#elif defined(ADAPTER_CMPLX_MAT)
subroutine Mat_Ptr_GetTrace(A, trace) bind(C, name="Mat_Ptr_GetTrace")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_GetTrace
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    real(kind=C_QREAL), intent(out) :: trace(2)
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_GetTrace(f_A, trace)
    return
end subroutine Mat_Ptr_GetTrace

subroutine Mat_Ptr_GetMatProdTrace(A, B, op_B, trace) &
    bind(C, name="Mat_Ptr_GetMatProdTrace")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_GetMatProdTrace
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    type(C_PTR), intent(in) :: B
    integer(kind=C_QINT), value, intent(in) :: op_B
    real(kind=C_QREAL), intent(out) :: trace(2)
    type(LANG_F_MATRIX), pointer :: f_A
    type(LANG_F_MATRIX), pointer :: f_B
    call c_f_pointer(A, f_A)
    call c_f_pointer(B, f_B)
    call Matrix_GetMatProdTrace(f_A, f_B, op_B, trace)
    return
end subroutine Mat_Ptr_GetMatProdTrace
#else
subroutine Mat_Ptr_GetTrace(A, trace) bind(C, name="Mat_Ptr_GetTrace")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_GetTrace
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    real(kind=C_QREAL), intent(out) :: trace
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_GetTrace(f_A, trace)
    return
end subroutine Mat_Ptr_GetTrace

subroutine Mat_Ptr_GetMatProdTrace(A, B, op_B, trace) &
    bind(C, name="Mat_Ptr_GetMatProdTrace")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_GetMatProdTrace
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    type(C_PTR), intent(in) :: B
    integer(kind=C_QINT), value, intent(in) :: op_B
    real(kind=C_QREAL), intent(out) :: trace
    type(LANG_F_MATRIX), pointer :: f_A
    type(LANG_F_MATRIX), pointer :: f_B
    call c_f_pointer(A, f_A)
    call c_f_pointer(B, f_B)
    call Matrix_GetMatProdTrace(f_A, f_B, op_B, trace)
    return
end subroutine Mat_Ptr_GetMatProdTrace
#endif

#if defined(QCMATRIX_ENABLE_VIEW)
subroutine Mat_Ptr_Write(A, len_mat_label, mat_label, view_option) &
    bind(C, name="Mat_Ptr_Write")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_Write
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: len_mat_label
    type(C_PTR), value, intent(in) :: mat_label
    integer(kind=C_QINT), value, intent(in) :: view_option
#include "api/qcmatrix_f_basic.h90"
    type(LANG_F_MATRIX), pointer :: f_A
    integer(kind=4), parameter :: STDOUT = 6
    character(kind=C_CHAR), pointer :: ptr_mat_label(:)
    character(len=len_mat_label) f_mat_label
    integer(kind=QINT) ic
    call c_f_pointer(A, f_A)
    if (.not.c_associated(mat_label)) then
        write(STDOUT,"(A)") "Mat_Ptr_Write>> mat_label is a C NULL pointer!"
        call QErrorExit(STDOUT, __LINE__, "Mat_Ptr_Write@src/adapter/f03_adapter_f.F90")
    end if
    call c_f_pointer(mat_label, ptr_mat_label, [len_mat_label])
    do ic = 1_QINT, len_mat_label
        f_mat_label(ic:ic) = ptr_mat_label(ic)(1:1)
    end do
    call Matrix_Write(f_A, f_mat_label, view_option)
    return
end subroutine Mat_Ptr_Write
#endif

#if defined(QCMATRIX_ENABLE_VIEW)
subroutine Mat_Ptr_Read(A, len_mat_label, mat_label, view_option) &
    bind(C, name="Mat_Ptr_Read")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_Read
    use, intrinsic :: iso_c_binding
    implicit none
    type(C_PTR), intent(in) :: A
    integer(kind=C_QINT), value, intent(in) :: len_mat_label
    type(C_PTR), value, intent(in) :: mat_label
    integer(kind=C_QINT), value, intent(in) :: view_option
#include "api/qcmatrix_f_basic.h90"
    type(LANG_F_MATRIX), pointer :: f_A
    integer(kind=4), parameter :: STDOUT = 6
    character(kind=C_CHAR), pointer :: ptr_mat_label(:)
    character(len=len_mat_label) f_mat_label
    integer(kind=QINT) ic
    call c_f_pointer(A, f_A)
    if (.not.c_associated(mat_label)) then
        write(STDOUT,"(A)") "Mat_Ptr_Read>> mat_label is a C NULL pointer!"
        call QErrorExit(STDOUT, __LINE__, "Mat_Ptr_Read@src/adapter/f03_adapter_f.F90")
    end if
    call c_f_pointer(mat_label, ptr_mat_label, [len_mat_label])
    do ic = 1_QINT, len_mat_label
        f_mat_label(ic:ic) = ptr_mat_label(ic)(1:1)
    end do
    call Matrix_Read(f_A, f_mat_label, view_option)
    return
end subroutine Mat_Ptr_Read
#endif

#if defined(ADAPTER_BLOCK_CMPLX) || defined(ADAPTER_CMPLX_MAT)
subroutine Mat_Ptr_Scale(scal_number, A) bind(C, name="Mat_Ptr_Scale")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_Scale
    use, intrinsic :: iso_c_binding
    implicit none
    real(kind=C_QREAL), intent(in) :: scal_number(2)
    type(C_PTR), intent(in) :: A
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_Scale(scal_number, f_A)
    return
end subroutine Mat_Ptr_Scale
#else
subroutine Mat_Ptr_Scale(scal_number, A) bind(C, name="Mat_Ptr_Scale")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_Scale
    use, intrinsic :: iso_c_binding
    implicit none
    real(kind=C_QREAL), value, intent(in) :: scal_number
    type(C_PTR), intent(in) :: A
    type(LANG_F_MATRIX), pointer :: f_A
    call c_f_pointer(A, f_A)
    call Matrix_Scale(scal_number, f_A)
    return
end subroutine Mat_Ptr_Scale
#endif

#if defined(ADAPTER_BLOCK_CMPLX) || defined(ADAPTER_CMPLX_MAT)
subroutine Mat_Ptr_AXPY(multiplier, X, Y) bind(C, name="Mat_Ptr_AXPY")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_AXPY
    use, intrinsic :: iso_c_binding
    implicit none
    real(kind=C_QREAL), intent(in) :: multiplier(2)
    type(C_PTR), intent(in) :: X
    type(C_PTR), intent(in) :: Y
    type(LANG_F_MATRIX), pointer :: f_X
    type(LANG_F_MATRIX), pointer :: f_Y
    call c_f_pointer(X, f_X)
    call c_f_pointer(Y, f_Y)
    call Matrix_AXPY(multiplier, f_X, f_Y)
    return
end subroutine Mat_Ptr_AXPY
#else
subroutine Mat_Ptr_AXPY(multiplier, X, Y) bind(C, name="Mat_Ptr_AXPY")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_AXPY
    use, intrinsic :: iso_c_binding
    implicit none
    real(kind=C_QREAL), value, intent(in) :: multiplier
    type(C_PTR), intent(in) :: X
    type(C_PTR), intent(in) :: Y
    type(LANG_F_MATRIX), pointer :: f_X
    type(LANG_F_MATRIX), pointer :: f_Y
    call c_f_pointer(X, f_X)
    call c_f_pointer(Y, f_Y)
    call Matrix_AXPY(multiplier, f_X, f_Y)
    return
end subroutine Mat_Ptr_AXPY
#endif

subroutine Mat_Ptr_Transpose(op_A, A, B) bind(C, name="Mat_Ptr_Transpose")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_Transpose
    use, intrinsic :: iso_c_binding
    implicit none
    integer(kind=C_QINT), value, intent(in) :: op_A
    type(C_PTR), intent(in) :: A
    type(C_PTR), intent(in) :: B
    type(LANG_F_MATRIX), pointer :: f_A
    type(LANG_F_MATRIX), pointer :: f_B
    call c_f_pointer(A, f_A)
    call c_f_pointer(B, f_B)
    call Matrix_Transpose(op_A, f_A, f_B)
    return
end subroutine Mat_Ptr_Transpose

#if defined(ADAPTER_BLOCK_CMPLX) || defined(ADAPTER_CMPLX_MAT)
subroutine Mat_Ptr_GEMM(op_A, op_B, alpha, A, B, beta, C) bind(C, name="Mat_Ptr_GEMM")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_GEMM
    use, intrinsic :: iso_c_binding
    implicit none
    integer(kind=C_QINT), value, intent(in) :: op_A
    integer(kind=C_QINT), value, intent(in) :: op_B
    real(kind=C_QREAL), intent(in) :: alpha(2)
    type(C_PTR), intent(in) :: A
    type(C_PTR), intent(in) :: B
    real(kind=C_QREAL), intent(in) :: beta(2)
    type(C_PTR), intent(in) :: C
    type(LANG_F_MATRIX), pointer :: f_A
    type(LANG_F_MATRIX), pointer :: f_B
    type(LANG_F_MATRIX), pointer :: f_C
    call c_f_pointer(A, f_A)
    call c_f_pointer(B, f_B)
    call c_f_pointer(C, f_C)
    call Matrix_GEMM(op_A, op_B, alpha, f_A, f_B, beta, f_C)
    return
end subroutine Mat_Ptr_GEMM
#else
subroutine Mat_Ptr_GEMM(op_A, op_B, alpha, A, B, beta, C) bind(C, name="Mat_Ptr_GEMM")
    use LANG_F_MODULE, only: LANG_F_MATRIX,Matrix_GEMM
    use, intrinsic :: iso_c_binding
    implicit none
    integer(kind=C_QINT), value, intent(in) :: op_A
    integer(kind=C_QINT), value, intent(in) :: op_B
    real(kind=C_QREAL), value, intent(in) :: alpha
    type(C_PTR), intent(in) :: A
    type(C_PTR), intent(in) :: B
    real(kind=C_QREAL), value, intent(in) :: beta
    type(C_PTR), intent(in) :: C
    type(LANG_F_MATRIX), pointer :: f_A
    type(LANG_F_MATRIX), pointer :: f_B
    type(LANG_F_MATRIX), pointer :: f_C
    call c_f_pointer(A, f_A)
    call c_f_pointer(B, f_B)
    call c_f_pointer(C, f_C)
    call Matrix_GEMM(op_A, op_B, alpha, f_A, f_B, beta, f_C)
    return
end subroutine Mat_Ptr_GEMM
#endif

