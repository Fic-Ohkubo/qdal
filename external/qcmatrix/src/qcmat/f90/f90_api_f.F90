!!  QcMatrix: an abstract matrix library
!!  Copyright 2012-2015 Bin Gao
!!
!!  QcMatrix is free software: you can redistribute it and/or modify
!!  it under the terms of the GNU Lesser General Public License as published by
!!  the Free Software Foundation, either version 3 of the License, or
!!  (at your option) any later version.
!!
!!  QcMatrix is distributed in the hope that it will be useful,
!!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
!!  GNU Lesser General Public License for more details.
!!
!!  You should have received a copy of the GNU Lesser General Public License
!!  along with QcMatrix. If not, see <http://www.gnu.org/licenses/>.
!!
!!  This file defines the QcMat type for the Fortran 90 APIs.
!!
!!  2014-03-11, Bin Gao:
!!  * generated by tools/qcmatrix_fortran.py

! size in bytes of the Fortran 90 integer(kind=QINT) (for the offset)
#if !defined(SIZEOF_VOID_P)
#define SIZEOF_VOID_P 8
#endif

module qcmatrix_f
    implicit none

    ! QcMat type (used by the user) whose address will be passed to QcMatrix functions,
    ! in which SIZEOF_VOID_P is the size in bytes of the Fortran 90 integer(kind=QINT) (for
    ! the offset), inspired by the PETSc library
    type, public :: QcMat
        private
        integer(kind=SIZEOF_VOID_P) f90_int
    end type QcMat

! parameters defined in QcMatrix library that will be used in Fortran APIs
#include "api/qcmatrix_f_api.h90"

    ! functions provided by the Fortran 90 APIs
    public :: QcMatCreate_f
    public :: QcMatDestroy_f
    public :: QcMatBlockCreate_f
    public :: QcMatSetSymType_f
    public :: QcMatSetDataType_f
    public :: QcMatSetDimMat_f
#if defined(QCMATRIX_STORAGE_MODE)
    public :: QcMatSetStorageMode_f
#endif
    public :: QcMatAssemble_f
    public :: QcMatGetDimBlock_f
    public :: QcMatGetSymType_f
    public :: QcMatGetDataType_f
    public :: QcMatGetDimMat_f
#if defined(QCMATRIX_STORAGE_MODE)
    public :: QcMatGetStorageMode_f
#endif
    public :: QcMatIsAssembled_f
    public :: QcMatSetValues_f
    public :: QcMatAddValues_f
    public :: QcMatGetValues_f
    public :: QcMatDuplicate_f
    public :: QcMatZeroEntries_f
    public :: QcMatGetTrace_f
    public :: QcMatGetMatProdTrace_f
#if defined(QCMATRIX_ENABLE_VIEW)
    public :: QcMatWrite_f
    public :: QcMatRead_f
#endif
    public :: QcMatScale_f
    public :: QcMatAXPY_f
    public :: QcMatTranspose_f
    public :: QcMatGEMM_f
#if defined(ADAPTER_F90_LANG)
    public :: QcMatSetExternalMat_f
    public :: QcMatGetExternalMat_f
#endif
    public :: QcMatMatCommutator_f
    public :: QcMatMatSCommutator_f
    public :: QcMatMatHermCommutator_f
    public :: QcMatMatSHermCommutator_f
    public :: QcMatSetRandMat_f
    public :: QcMatIsEqual_f
    public :: QcMatCfArray_f
    public :: QcMatGetAllValues_f

    contains

    function QcMatCreate_f(A) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(out) :: A
        call f90_api_QcMatCreate(A, ierr)
    end function QcMatCreate_f

    function QcMatDestroy_f(A) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(inout) :: A
        call f90_api_QcMatDestroy(A, ierr)
    end function QcMatDestroy_f

    function QcMatBlockCreate_f(A, dim_block) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(in) :: dim_block
        call f90_api_QcMatBlockCreate(A, dim_block, ierr)
    end function QcMatBlockCreate_f

    function QcMatSetSymType_f(A, sym_type) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(in) :: sym_type
        call f90_api_QcMatSetSymType(A, sym_type, ierr)
    end function QcMatSetSymType_f

    function QcMatSetDataType_f(A,             &
                                num_blocks,    &
                                idx_block_row, &
                                idx_block_col, &
                                data_type) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(in) :: num_blocks
        integer(kind=QINT), intent(in) :: idx_block_row(num_blocks)
        integer(kind=QINT), intent(in) :: idx_block_col(num_blocks)
        integer(kind=QINT), intent(in) :: data_type(num_blocks)
        call f90_api_QcMatSetDataType(A,             &
                                      num_blocks,    &
                                      idx_block_row, &
                                      idx_block_col, &
                                      data_type,     &
                                      ierr)
    end function QcMatSetDataType_f

    function QcMatSetDimMat_f(A, num_row, num_col) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(in) :: num_row
        integer(kind=QINT), intent(in) :: num_col
        call f90_api_QcMatSetDimMat(A, num_row, num_col, ierr)
    end function QcMatSetDimMat_f

#if defined(QCMATRIX_STORAGE_MODE)
    function QcMatSetStorageMode_f(A, storage_mode) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(in) :: storage_mode
        call f90_api_QcMatSetStorageMode(A, storage_mode, ierr)
    end function QcMatSetStorageMode_f
#endif

    function QcMatAssemble_f(A) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        call f90_api_QcMatAssemble(A, ierr)
    end function QcMatAssemble_f

    function QcMatGetDimBlock_f(A, dim_block) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(out) :: dim_block
        call f90_api_QcMatGetDimBlock(A, dim_block, ierr)
    end function QcMatGetDimBlock_f

    function QcMatGetSymType_f(A, sym_type) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(out) :: sym_type
        call f90_api_QcMatGetSymType(A, sym_type, ierr)
    end function QcMatGetSymType_f

    function QcMatGetDataType_f(A,             &
                                num_blocks,    &
                                idx_block_row, &
                                idx_block_col, &
                                data_type) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(in) :: num_blocks
        integer(kind=QINT), intent(in) :: idx_block_row(num_blocks)
        integer(kind=QINT), intent(in) :: idx_block_col(num_blocks)
        integer(kind=QINT), intent(out) :: data_type(num_blocks)
        call f90_api_QcMatGetDataType(A,             &
                                      num_blocks,    &
                                      idx_block_row, &
                                      idx_block_col, &
                                      data_type,     &
                                      ierr)
    end function QcMatGetDataType_f

    function QcMatGetDimMat_f(A, num_row, num_col) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(out) :: num_row
        integer(kind=QINT), intent(out) :: num_col
        call f90_api_QcMatGetDimMat(A, num_row, num_col, ierr)
    end function QcMatGetDimMat_f

#if defined(QCMATRIX_STORAGE_MODE)
    function QcMatGetStorageMode_f(A, storage_mode) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(out) :: storage_mode
        call f90_api_QcMatGetStorageMode(A, storage_mode, ierr)
    end function QcMatGetStorageMode_f
#endif

    function QcMatIsAssembled_f(A, assembled) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        logical(kind=4), intent(out) :: assembled
        integer(kind=QINT) c_assembled
        call f90_api_QcMatIsAssembled(A, c_assembled, ierr)
        if (c_assembled==QTRUE) then
            assembled = .true.
        else
            assembled = .false.
        end if
    end function QcMatIsAssembled_f

    function QcMatSetValues_f(A,             &
                              idx_block_row, &
                              idx_block_col, &
                              idx_first_row, &
                              num_row_set,   &
                              idx_first_col, &
                              num_col_set,   &
                              values_real,   &
                              values_imag) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(in) :: idx_block_row
        integer(kind=QINT), intent(in) :: idx_block_col
        integer(kind=QINT), intent(in) :: idx_first_row
        integer(kind=QINT), intent(in) :: num_row_set
        integer(kind=QINT), intent(in) :: idx_first_col
        integer(kind=QINT), intent(in) :: num_col_set
        real(kind=QREAL), optional, intent(in) :: values_real(num_row_set*num_col_set)
        real(kind=QREAL), optional, intent(in) :: values_imag(num_row_set*num_col_set)
        if (present(values_real)) then
            call f90_api_QcMatSetRealValues(A,             &
                                            idx_block_row, &
                                            idx_block_col, &
                                            idx_first_row, &
                                            num_row_set,   &
                                            idx_first_col, &
                                            num_col_set,   &
                                            values_real,   &
                                            ierr)
        end if
        if (present(values_imag)) then
            call f90_api_QcMatSetImagValues(A,             &
                                            idx_block_row, &
                                            idx_block_col, &
                                            idx_first_row, &
                                            num_row_set,   &
                                            idx_first_col, &
                                            num_col_set,   &
                                            values_imag,   &
                                            ierr)
        end if
    end function QcMatSetValues_f

    function QcMatAddValues_f(A,             &
                              idx_block_row, &
                              idx_block_col, &
                              idx_first_row, &
                              num_row_add,   &
                              idx_first_col, &
                              num_col_add,   &
                              values_real,   &
                              values_imag) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(in) :: idx_block_row
        integer(kind=QINT), intent(in) :: idx_block_col
        integer(kind=QINT), intent(in) :: idx_first_row
        integer(kind=QINT), intent(in) :: num_row_add
        integer(kind=QINT), intent(in) :: idx_first_col
        integer(kind=QINT), intent(in) :: num_col_add
        real(kind=QREAL), optional, intent(in) :: values_real(num_row_add*num_col_add)
        real(kind=QREAL), optional, intent(in) :: values_imag(num_row_add*num_col_add)
        if (present(values_real)) then
            call f90_api_QcMatAddRealValues(A,             &
                                            idx_block_row, &
                                            idx_block_col, &
                                            idx_first_row, &
                                            num_row_add,   &
                                            idx_first_col, &
                                            num_col_add,   &
                                            values_real,   &
                                            ierr)
        end if
        if (present(values_imag)) then
            call f90_api_QcMatAddImagValues(A,             &
                                            idx_block_row, &
                                            idx_block_col, &
                                            idx_first_row, &
                                            num_row_add,   &
                                            idx_first_col, &
                                            num_col_add,   &
                                            values_imag,   &
                                            ierr)
        end if
    end function QcMatAddValues_f

    function QcMatGetValues_f(A,             &
                              idx_block_row, &
                              idx_block_col, &
                              idx_first_row, &
                              num_row_get,   &
                              idx_first_col, &
                              num_col_get,   &
                              values_real,   &
                              values_imag) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(in) :: idx_block_row
        integer(kind=QINT), intent(in) :: idx_block_col
        integer(kind=QINT), intent(in) :: idx_first_row
        integer(kind=QINT), intent(in) :: num_row_get
        integer(kind=QINT), intent(in) :: idx_first_col
        integer(kind=QINT), intent(in) :: num_col_get
        real(kind=QREAL), optional, intent(out) :: values_real(num_row_get*num_col_get)
        real(kind=QREAL), optional, intent(out) :: values_imag(num_row_get*num_col_get)
        if (present(values_real)) then
            call f90_api_QcMatGetRealValues(A,             &
                                            idx_block_row, &
                                            idx_block_col, &
                                            idx_first_row, &
                                            num_row_get,   &
                                            idx_first_col, &
                                            num_col_get,   &
                                            values_real,   &
                                            ierr)
        end if
        if (present(values_imag)) then
            call f90_api_QcMatGetImagValues(A,             &
                                            idx_block_row, &
                                            idx_block_col, &
                                            idx_first_row, &
                                            num_row_get,   &
                                            idx_first_col, &
                                            num_col_get,   &
                                            values_imag,   &
                                            ierr)
        end if
    end function QcMatGetValues_f

    function QcMatDuplicate_f(A, duplicate_option, B) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(in) :: duplicate_option
        type(QcMat), intent(in) :: B
        call f90_api_QcMatDuplicate(A, duplicate_option, B, ierr)
    end function QcMatDuplicate_f

    function QcMatZeroEntries_f(A) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        call f90_api_QcMatZeroEntries(A, ierr)
    end function QcMatZeroEntries_f

    function QcMatGetTrace_f(A, num_blocks, trace) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(in) :: num_blocks
        real(kind=QREAL), intent(out) :: trace(2*num_blocks)
        call f90_api_QcMatGetTrace(A, num_blocks, trace, ierr)
    end function QcMatGetTrace_f

    function QcMatGetMatProdTrace_f(A, B, op_B, num_blocks, trace) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        type(QcMat), intent(in) :: B
        integer(kind=QINT), intent(in) :: op_B
        integer(kind=QINT), intent(in) :: num_blocks
        real(kind=QREAL), intent(out) :: trace(2*num_blocks)
        call f90_api_QcMatGetMatProdTrace(A, B, op_B, num_blocks, trace, ierr)
    end function QcMatGetMatProdTrace_f

#if defined(QCMATRIX_ENABLE_VIEW)
    function QcMatWrite_f(A, mat_label, view_option) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        character*(*), intent(in) :: mat_label
        integer(kind=QINT), intent(in) :: view_option
        call f90_api_QcMatWrite(A, mat_label//char(0), view_option, ierr)
    end function QcMatWrite_f
#endif

#if defined(QCMATRIX_ENABLE_VIEW)
    function QcMatRead_f(A, mat_label, view_option) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        character*(*), intent(in) :: mat_label
        integer(kind=QINT), intent(in) :: view_option
        call f90_api_QcMatRead(A, mat_label//char(0), view_option, ierr)
    end function QcMatRead_f
#endif

    function QcMatScale_f(scal_number, A) result(ierr)
        integer(kind=4) :: ierr
        real(kind=QREAL), intent(in) :: scal_number(2)
        type(QcMat), intent(in) :: A
        call f90_api_QcMatScale(scal_number, A, ierr)
    end function QcMatScale_f

    function QcMatAXPY_f(multiplier, X, Y) result(ierr)
        integer(kind=4) :: ierr
        real(kind=QREAL), intent(in) :: multiplier(2)
        type(QcMat), intent(in) :: X
        type(QcMat), intent(in) :: Y
        call f90_api_QcMatAXPY(multiplier, X, Y, ierr)
    end function QcMatAXPY_f

    function QcMatTranspose_f(op_A, A, B) result(ierr)
        integer(kind=4) :: ierr
        integer(kind=QINT), intent(in) :: op_A
        type(QcMat), intent(in) :: A
        type(QcMat), intent(in) :: B
        call f90_api_QcMatTranspose(op_A, A, B, ierr)
    end function QcMatTranspose_f

    function QcMatGEMM_f(op_A, op_B, alpha, A, B, beta, C) result(ierr)
        integer(kind=4) :: ierr
        integer(kind=QINT), intent(in) :: op_A
        integer(kind=QINT), intent(in) :: op_B
        real(kind=QREAL), intent(in) :: alpha(2)
        type(QcMat), intent(in) :: A
        type(QcMat), intent(in) :: B
        real(kind=QREAL), intent(in) :: beta(2)
        type(QcMat), intent(in) :: C
        call f90_api_QcMatGEMM(op_A, op_B, alpha, A, B, beta, C, ierr)
    end function QcMatGEMM_f

#if defined(ADAPTER_F90_LANG)
! SIZEOF_F_TYPE_P is the size in bytes of derived types with a single pointer member,
! could be changed by -DSIZEOF_F_TYPE_P=XX
#include "adapter/sizeof_f_type_p.h"

#if defined(ADAPTER_BLOCK_CMPLX)
    function QcMatSetExternalMat_f(A, A_ext) result(ierr)
        use f90_adapter
        integer(kind=4) :: ierr
        type(QcMat), intent(inout) :: A
        type(LANG_F_MATRIX), intent(in) :: A_ext
        integer(kind=QINT) iA(SIZEOF_F_TYPE_P)
        call f90_api_QcMatGetAdapterMat(A, iA, ierr)
        if (ierr/=QSUCCESS) return
        call Mat_Ptr_SetExternalMat(iA, A_ext)
        call f90_api_QcMatSetAdapterMat(A, iA, ierr)
    end function QcMatSetExternalMat_f

    function QcMatGetExternalMat_f(A, A_ext) result(ierr)
        use f90_adapter
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        type(LANG_F_MATRIX), pointer, intent(inout) :: A_ext
        integer(kind=QINT) iA(SIZEOF_F_TYPE_P)
        call f90_api_QcMatGetAdapterMat(A, iA, ierr)
        call Mat_Ptr_GetExternalMat(iA, A_ext)
    end function QcMatGetExternalMat_f
#elif defined(ADAPTER_BLOCK_REAL)
    function QcMatSetExternalMat_f(A, data_type, A_ext) result(ierr)
        use f90_adapter
        integer(kind=4) :: ierr
        type(QcMat), intent(inout) :: A
        integer(kind=QINT), intent(in) :: data_type
        type(LANG_F_MATRIX), pointer, intent(in) :: A_ext
        integer(kind=QINT) iA(SIZEOF_F_TYPE_P)
        call f90_api_QcMatGetAdapterMat(A, data_type, iA, ierr)
        if (ierr/=QSUCCESS) return
        call Mat_Ptr_SetExternalMat(iA, A_ext)
        call f90_api_QcMatSetAdapterMat(A, data_type, iA, ierr)
    end function QcMatSetExternalMat_f

    function QcMatGetExternalMat_f(A, data_type, A_ext) result(ierr)
        use f90_adapter
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(in) :: data_type
        type(LANG_F_MATRIX), pointer, intent(inout) :: A_ext
        integer(kind=QINT) iA(SIZEOF_F_TYPE_P)
        call f90_api_QcMatGetAdapterMat(A, data_type, iA, ierr)
        call Mat_Ptr_GetExternalMat(iA, A_ext)
    end function QcMatGetExternalMat_f
#elif defined(ADAPTER_CMPLX_MAT)
    function QcMatSetExternalMat_f(A, idx_block_row, idx_block_col, A_ext) result(ierr)
        use f90_adapter
        integer(kind=4) :: ierr
        type(QcMat), intent(inout) :: A
        integer(kind=QINT), intent(in) :: idx_block_row
        integer(kind=QINT), intent(in) :: idx_block_col
        type(LANG_F_MATRIX), pointer, intent(in) :: A_ext
        integer(kind=QINT) iA(SIZEOF_F_TYPE_P)
        call f90_api_QcMatGetAdapterMat(A, idx_block_row, idx_block_col, iA, ierr)
        if (ierr/=QSUCCESS) return
        call Mat_Ptr_SetExternalMat(iA, A_ext)
        call f90_api_QcMatSetAdapterMat(A, idx_block_row, idx_block_col, iA, ierr)
    end function QcMatSetExternalMat_f

    function QcMatGetExternalMat_f(A, idx_block_row, idx_block_col, A_ext) result(ierr)
        use f90_adapter
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(in) :: idx_block_row
        integer(kind=QINT), intent(in) :: idx_block_col
        type(LANG_F_MATRIX), pointer, intent(inout) :: A_ext
        integer(kind=QINT) iA(SIZEOF_F_TYPE_P)
        call f90_api_QcMatGetAdapterMat(A, idx_block_row, idx_block_col, iA, ierr)
        call Mat_Ptr_GetExternalMat(iA, A_ext)
    end function QcMatGetExternalMat_f
#elif defined(ADAPTER_REAL_MAT)
    function QcMatSetExternalMat_f(A,             &
                                   idx_block_row, &
                                   idx_block_col, &
                                   data_type,     &
                                   A_ext) result(ierr)
        use f90_adapter
        integer(kind=4) :: ierr
        type(QcMat), intent(inout) :: A
        integer(kind=QINT), intent(in) :: idx_block_row
        integer(kind=QINT), intent(in) :: idx_block_col
        integer(kind=QINT), intent(in) :: data_type
        type(LANG_F_MATRIX), pointer, intent(in) :: A_ext
        integer(kind=QINT) iA(SIZEOF_F_TYPE_P)
        call f90_api_QcMatGetAdapterMat(A,             &
                                        idx_block_row, &
                                        idx_block_col, &
                                        data_type,     &
                                        iA,            &
                                        ierr)
        if (ierr/=QSUCCESS) return
        call Mat_Ptr_SetExternalMat(iA, A_ext)
        call f90_api_QcMatSetAdapterMat(A,             &
                                        idx_block_row, &
                                        idx_block_col, &
                                        data_type,     &
                                        iA,            &
                                        ierr)
    end function QcMatSetExternalMat_f

    function QcMatGetExternalMat_f(A,             &
                                   idx_block_row, &
                                   idx_block_col, &
                                   data_type,     &
                                   A_ext) result(ierr)
        use f90_adapter
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(in) :: idx_block_row
        integer(kind=QINT), intent(in) :: idx_block_col
        integer(kind=QINT), intent(in) :: data_type
        type(LANG_F_MATRIX), pointer, intent(inout) :: A_ext
        integer(kind=QINT) iA(SIZEOF_F_TYPE_P)
        call f90_api_QcMatGetAdapterMat(A,             &
                                        idx_block_row, &
                                        idx_block_col, &
                                        data_type,     &
                                        iA,            &
                                        ierr)
        call Mat_Ptr_GetExternalMat(iA, A_ext)
    end function QcMatGetExternalMat_f
#endif
#endif

    function QcMatMatCommutator_f(A, B, C) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        type(QcMat), intent(in) :: B
        type(QcMat), intent(in) :: C
        call f90_api_QcMatMatCommutator(A, B, C, ierr)
    end function QcMatMatCommutator_f

    function QcMatMatSCommutator_f(A, B, S, C) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        type(QcMat), intent(in) :: B
        type(QcMat), intent(in) :: S
        type(QcMat), intent(in) :: C
        call f90_api_QcMatMatSCommutator(A, B, S, C, ierr)
    end function QcMatMatSCommutator_f

    function QcMatMatHermCommutator_f(A, B, C) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        type(QcMat), intent(in) :: B
        type(QcMat), intent(in) :: C
        call f90_api_QcMatMatHermCommutator(A, B, C, ierr)
    end function QcMatMatHermCommutator_f

    function QcMatMatSHermCommutator_f(A, B, S, C) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        type(QcMat), intent(in) :: B
        type(QcMat), intent(in) :: S
        type(QcMat), intent(in) :: C
        call f90_api_QcMatMatSHermCommutator(A, B, S, C, ierr)
    end function QcMatMatSHermCommutator_f

    function QcMatSetRandMat_f(A,         &
                               sym_type,  &
                               data_type, &
                               dim_block, &
                               num_row,   &
                               num_col) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(in) :: sym_type
        integer(kind=QINT), intent(in) :: data_type
        integer(kind=QINT), intent(in) :: dim_block
        integer(kind=QINT), intent(in) :: num_row
        integer(kind=QINT), intent(in) :: num_col
        call f90_api_QcMatSetRandMat(A,         &
                                     sym_type,  &
                                     data_type, &
                                     dim_block, &
                                     num_row,   &
                                     num_col,   &
                                     ierr)
    end function QcMatSetRandMat_f

    function QcMatIsEqual_f(A, B, cf_values, is_equal) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        type(QcMat), intent(in) :: B
        logical(kind=4), intent(in) :: cf_values
        logical(kind=4), intent(out) :: is_equal
        integer(kind=QINT) c_cf_values
        integer(kind=QINT) c_is_equal
        if (cf_values) then
            c_cf_values = QTRUE
        else
            c_cf_values = QFALSE
        end if
        call f90_api_QcMatIsEqual(A, B, c_cf_values, c_is_equal, ierr)
        if (c_is_equal==QTRUE) then
            is_equal = .true.
        else
            is_equal = .false.
        end if
    end function QcMatIsEqual_f

    function QcMatCfArray_f(A,           &
                            row_major,   &
                            size_values, &
                            values_real, &
                            values_imag, &
                            is_equal) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        logical(kind=4), intent(in) :: row_major
        integer(kind=QINT), intent(in) :: size_values
        real(kind=QREAL), intent(in) :: values_real(size_values)
        real(kind=QREAL), intent(in) :: values_imag(size_values)
        logical(kind=4), intent(out) :: is_equal
        integer(kind=QINT) c_row_major
        integer(kind=QINT) c_is_equal
        if (row_major) then
            c_row_major = QTRUE
        else
            c_row_major = QFALSE
        end if
        call f90_api_QcMatCfArray(A,           &
                                  c_row_major, &
                                  size_values, &
                                  values_real, &
                                  values_imag, &
                                  c_is_equal,  &
                                  ierr)
        if (c_is_equal==QTRUE) then
            is_equal = .true.
        else
            is_equal = .false.
        end if
    end function QcMatCfArray_f

    function QcMatGetAllValues_f(A,           &
                                 row_major,   &
                                 size_values, &
                                 values_real, &
                                 values_imag) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        logical(kind=4), intent(in) :: row_major
        integer(kind=QINT), intent(in) :: size_values
        real(kind=QREAL), intent(out) :: values_real(size_values)
        real(kind=QREAL), intent(out) :: values_imag(size_values)
        integer(kind=QINT) c_row_major
        if (row_major) then
            c_row_major = QTRUE
        else
            c_row_major = QFALSE
        end if
        call f90_api_QcMatGetAllValues(A,           &
                                       c_row_major, &
                                       size_values, &
                                       values_real, &
                                       values_imag, &
                                       ierr)
    end function QcMatGetAllValues_f

end module qcmatrix_f
