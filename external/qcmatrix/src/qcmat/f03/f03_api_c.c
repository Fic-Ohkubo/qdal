/*
   QcMatrix: an abstract matrix library
   Copyright 2012-2015 Bin Gao

   QcMatrix is free software: you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   QcMatrix is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public License
   along with QcMatrix. If not, see <http://www.gnu.org/licenses/>.

   This file implements the functions of Fortran 2003 APIs.

   2014-03-11, Bin Gao:
   * generated by tools/qcmatrix_fortran.py
*/

#include "qcmatrix.h"

QErrorCode f03_api_QcMatCreate(QVoid **A)
{
    QcMat *c_A;
    QErrorCode ierr;
    c_A = (QcMat *)malloc(sizeof(QcMat));
    if (c_A==NULL) {
        QErrorExit(FILE_AND_LINE, "failed to allocate memory for c_A");
    }
    ierr = QcMatCreate(c_A);
    *A = (QVoid *)(c_A);
    return ierr;
}

QErrorCode f03_api_QcMatDestroy(QVoid **A)
{
    QcMat *c_A;
    QErrorCode ierr;
    c_A = (QcMat *)(*A);
    ierr = QcMatDestroy(c_A);
    *A = NULL;
    A = NULL;
    return ierr;
}

QErrorCode f03_api_QcMatSetSymType(QVoid *A, const QInt sym_type)
{
    /* defined symmetry types, to be consistent with include/api/qcmatrix_f_mat_symmetry.h90 */
    QcSymType def_sym_type[3]={QANTISYMMAT,QNONSYMMAT,QSYMMAT};
    QErrorCode ierr;
    ierr = QcMatSetSymType(A, def_sym_type[sym_type+1]);
    return ierr;
}

QErrorCode f03_api_QcMatSetDataType(QVoid *A,
                                    const QInt num_blocks,
                                    const QInt idx_block_row[],
                                    const QInt idx_block_col[],
                                    const QInt data_type[])
{
    /* defined data types, to be consistent with include/api/qcmatrix_f_mat_data.h90 */
    QcDataType def_data_type[4]={QIMAGMAT,QCMPLXMAT,QREALMAT,QNULLMAT};
    QcDataType *c_data_type;
    QInt iblk;
    QErrorCode ierr;
    c_data_type = (QcDataType *)malloc(num_blocks*sizeof(QcDataType));
    if (c_data_type==NULL) {
        QErrorExit(FILE_AND_LINE, "failed to allocate memory for c_data_type");
    }
    for (iblk=0; iblk<num_blocks; iblk++) {
        c_data_type[iblk] = def_data_type[data_type[iblk]+1];
    }
    ierr = QcMatSetDataType(A, num_blocks, idx_block_row, idx_block_col, c_data_type);
    free(c_data_type);
    c_data_type = NULL;
    return ierr;
}

#if defined(QCMATRIX_STORAGE_MODE)
/* FIXME: converts QInt to QcStorageMode */
QErrorCode f03_api_QcMatSetStorageMode(QVoid *A, const QcStorageMode storage_mode)
{
    QErrorCode ierr;
    ierr = QcMatSetStorageMode(A, storage_mode);
    return ierr;
}
#endif

QErrorCode f03_api_QcMatGetSymType(QVoid *A, QInt *sym_type)
{
    /* converts symmetry types, to be consistent with
       include/api/qcmatrix_f_mat_symmetry.h90 and include/types/mat_symmetry.h */
    QInt def_sym_type[3]={-1,0,1};
    QcSymType c_sym_type;
    QErrorCode ierr;
    ierr = QcMatGetSymType(A, &c_sym_type);
    *sym_type = def_sym_type[c_sym_type+1];
    return ierr;
}

QErrorCode f03_api_QcMatGetDataType(QVoid *A,
                                    const QInt num_blocks,
                                    const QInt idx_block_row[],
                                    const QInt idx_block_col[],
                                    QInt *data_type)
{
    /* defined data types, to be consistent with
       include/api/qcmatrix_f_mat_data.h90 and include/types/mat_data.h */
    QInt def_data_type[4]={-1,0,1,2};
    QcDataType *c_data_type;
    QInt iblk;
    QErrorCode ierr;
    c_data_type = (QcDataType *)malloc(num_blocks*sizeof(QcDataType));
    if (c_data_type==NULL) {
        QErrorExit(FILE_AND_LINE, "failed to allocate memory for c_data_type");
    }
    ierr = QcMatGetDataType(A, num_blocks, idx_block_row, idx_block_col, c_data_type);
    for (iblk=0; iblk<num_blocks; iblk++) {
        data_type[iblk] = def_data_type[c_data_type[iblk]+1];
    }
    free(c_data_type);
    c_data_type = NULL;
    return ierr;
}

#if defined(QCMATRIX_STORAGE_MODE)
/* FIXME: converts QInt to QcStorageMode */
QErrorCode f03_api_QcMatGetStorageMode(QVoid *A, QcStorageMode *storage_mode)
{
    QErrorCode ierr;
    ierr = QcMatGetStorageMode(A, storage_mode);
    return ierr;
}
#endif

QErrorCode f03_api_QcMatIsAssembled(QVoid *A, QInt *assembled)
{
    /* Boolean type, to be consistent with
       include/api/qcmatrix_f_boolean.h90 and include/types/qcmatrix_basic_types.h */
    QInt f_Boolean[2]={0,1};
    QBool c_assembled;
    QErrorCode ierr;
    ierr = QcMatIsAssembled(A, &c_assembled);
    *assembled = f_Boolean[c_assembled];
    return ierr;
}

QErrorCode f03_api_QcMatSetRealValues(QVoid *A,
                                      const QInt idx_block_row,
                                      const QInt idx_block_col,
                                      const QInt idx_first_row,
                                      const QInt num_row_set,
                                      const QInt idx_first_col,
                                      const QInt num_col_set,
                                      const QReal *values)
{
    QErrorCode ierr;
    ierr = QcMatSetValues(A,
                          idx_block_row,
                          idx_block_col,
                          idx_first_row,
                          num_row_set,
                          idx_first_col,
                          num_col_set,
                          values,
                          NULL);
    return ierr;
}

QErrorCode f03_api_QcMatSetImagValues(QVoid *A,
                                      const QInt idx_block_row,
                                      const QInt idx_block_col,
                                      const QInt idx_first_row,
                                      const QInt num_row_set,
                                      const QInt idx_first_col,
                                      const QInt num_col_set,
                                      const QReal *values)
{
    QErrorCode ierr;
    ierr = QcMatSetValues(A,
                          idx_block_row,
                          idx_block_col,
                          idx_first_row,
                          num_row_set,
                          idx_first_col,
                          num_col_set,
                          NULL,
                          values);
    return ierr;
}

QErrorCode f03_api_QcMatAddRealValues(QVoid *A,
                                      const QInt idx_block_row,
                                      const QInt idx_block_col,
                                      const QInt idx_first_row,
                                      const QInt num_row_add,
                                      const QInt idx_first_col,
                                      const QInt num_col_add,
                                      const QReal *values)
{
    QErrorCode ierr;
    ierr = QcMatAddValues(A,
                          idx_block_row,
                          idx_block_col,
                          idx_first_row,
                          num_row_add,
                          idx_first_col,
                          num_col_add,
                          values,
                          NULL);
    return ierr;
}

QErrorCode f03_api_QcMatAddImagValues(QVoid *A,
                                      const QInt idx_block_row,
                                      const QInt idx_block_col,
                                      const QInt idx_first_row,
                                      const QInt num_row_add,
                                      const QInt idx_first_col,
                                      const QInt num_col_add,
                                      const QReal *values)
{
    QErrorCode ierr;
    ierr = QcMatAddValues(A,
                          idx_block_row,
                          idx_block_col,
                          idx_first_row,
                          num_row_add,
                          idx_first_col,
                          num_col_add,
                          NULL,
                          values);
    return ierr;
}

QErrorCode f03_api_QcMatGetRealValues(QVoid *A,
                                      const QInt idx_block_row,
                                      const QInt idx_block_col,
                                      const QInt idx_first_row,
                                      const QInt num_row_get,
                                      const QInt idx_first_col,
                                      const QInt num_col_get,
                                      QReal *values)
{
    QErrorCode ierr;
    ierr = QcMatGetValues(A,
                          idx_block_row,
                          idx_block_col,
                          idx_first_row,
                          num_row_get,
                          idx_first_col,
                          num_col_get,
                          values,
                          NULL);
    return ierr;
}

QErrorCode f03_api_QcMatGetImagValues(QVoid *A,
                                      const QInt idx_block_row,
                                      const QInt idx_block_col,
                                      const QInt idx_first_row,
                                      const QInt num_row_get,
                                      const QInt idx_first_col,
                                      const QInt num_col_get,
                                      QReal *values)
{
    QErrorCode ierr;
    ierr = QcMatGetValues(A,
                          idx_block_row,
                          idx_block_col,
                          idx_first_row,
                          num_row_get,
                          idx_first_col,
                          num_col_get,
                          NULL,
                          values);
    return ierr;
}

QErrorCode f03_api_QcMatDuplicate(QVoid *A,
                                  const QInt duplicate_option,
                                  QVoid *B)
{
    /* defined duplicate option, to be consistent with
       include/api/qcmatrix_f_mat_duplicate.h90 and include/types/mat_duplicate.h */
    QcDuplicateOption def_dup_option[2]={COPY_PATTERN_ONLY,COPY_PATTERN_AND_VALUE};
    QErrorCode ierr;
    ierr = QcMatDuplicate(A, def_dup_option[duplicate_option], B);
    return ierr;
}

QErrorCode f03_api_QcMatGetMatProdTrace(QVoid *A,
                                        QVoid *B,
                                        const QInt op_B,
                                        const QInt num_blocks,
                                        QReal *trace)
{
    /* defined operations on the matrix, to be consistent with
       include/api/qcmatrix_f_mat_operations.h90 and include/types/mat_operations.h */
    QcMatOperation def_mat_op[4]={MAT_NO_OPERATION,
                                  MAT_TRANSPOSE,
                                  MAT_HERM_TRANSPOSE,
                                  MAT_COMPLEX_CONJUGATE};
    QErrorCode ierr;
    ierr = QcMatGetMatProdTrace(A, B, def_mat_op[op_B], num_blocks, trace);
    return ierr;
}

#if defined(QCMATRIX_ENABLE_VIEW)
QErrorCode f03_api_QcMatWrite(QVoid *A,
                              const QChar *mat_label,
                              const QInt view_option)
{
    /* defined view option, to be consistend with
       include/api/qcmatrix_f_mat_view.h90 and include/types/mat_view.h */
    QcViewOption def_view_option[2]={BINARY_VIEW,ASCII_VIEW};
    QErrorCode ierr;
    ierr = QcMatWrite(A, mat_label, def_view_option[view_option]);
    return ierr;
}

QErrorCode f03_api_QcMatRead(QVoid *A,
                             const QChar *mat_label,
                             const QInt view_option)
{
    /* defined view option, to be consistend with
       include/api/qcmatrix_f_mat_view.h90 and include/types/mat_view.h */
    QcViewOption def_view_option[2]={BINARY_VIEW,ASCII_VIEW};
    QErrorCode ierr;
    ierr = QcMatRead(A, mat_label, def_view_option[view_option]);
    return ierr;
}
#endif

QErrorCode f03_api_QcMatTranspose(const QInt op_A, QVoid *A, QVoid *B)
{
    /* defined operations on the matrix, to be consistent with
       include/api/qcmatrix_f_mat_operations.h90 and include/types/mat_operations.h */
    QcMatOperation def_mat_op[4]={MAT_NO_OPERATION,
                                  MAT_TRANSPOSE,
                                  MAT_HERM_TRANSPOSE,
                                  MAT_COMPLEX_CONJUGATE};
    QErrorCode ierr;
    ierr = QcMatTranspose(def_mat_op[op_A], A, B);
    return ierr;
}

QErrorCode f03_api_QcMatGEMM(const QInt op_A,
                             const QInt op_B,
                             const QReal alpha[],
                             QVoid *A,
                             QVoid *B,
                             const QReal beta[],
                             QVoid *C)
{
    /* defined operations on the matrix, to be consistent with
       include/api/qcmatrix_f_mat_operations.h90 and include/types/mat_operations.h */
    QcMatOperation def_mat_op[4]={MAT_NO_OPERATION,
                                  MAT_TRANSPOSE,
                                  MAT_HERM_TRANSPOSE,
                                  MAT_COMPLEX_CONJUGATE};
    QErrorCode ierr;
    ierr = QcMatGEMM(def_mat_op[op_A], def_mat_op[op_B], alpha, A, B, beta, C);
    return ierr;
}

#if defined(ADAPTER_F03_LANG)
#if defined(ADAPTER_BLOCK_REAL)
QErrorCode f03_api_QcMatSetAdapterMat(QVoid *A, const QInt data_type, QVoid **f_A)
{
    RealMat *A_adapter;
    /* defined data types, to be consistent with include/api/qcmatrix_f_mat_data.h90 */
    QcDataType def_data_type[4]={QIMAGMAT,QCMPLXMAT,QREALMAT,QNULLMAT};
    QErrorCode ierr;
    ierr = QcMatSetAdapterMat(A, def_data_type[data_type+1], &A_adapter);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatSetAdapterMat");
    ierr = AdapterMatSetExternalMat(A_adapter, f_A);
    A_adapter = NULL;
    return ierr;
}

QErrorCode f03_api_QcMatGetAdapterMat(QVoid *A, const QInt data_type, QVoid **f_A)
{
    RealMat *A_adapter;
    /* defined data types, to be consistent with include/api/qcmatrix_f_mat_data.h90 */
    QcDataType def_data_type[4]={QIMAGMAT,QCMPLXMAT,QREALMAT,QNULLMAT};
    QErrorCode ierr;
    ierr = QcMatGetAdapterMat(A, def_data_type[data_type+1], &A_adapter);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatGetAdapterMat");
    ierr = AdapterMatGetExternalMat(A_adapter, f_A);
    A_adapter = NULL;
    return ierr;
}
#elif defined(ADAPTER_CMPLX_MAT)
QErrorCode f03_api_QcMatSetAdapterMat(QVoid *A,
                                      const QInt idx_block_row,
                                      const QInt idx_block_col,
                                      QVoid **f_A)
{
    CmplxMat *A_adapter;
    QErrorCode ierr;
    ierr = QcMatSetAdapterMat(A, idx_block_row, idx_block_col, &A_adapter);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatSetAdapterMat");
    ierr = AdapterMatSetExternalMat(A_adapter, f_A);
    A_adapter = NULL;
    return ierr;
}

QErrorCode f03_api_QcMatGetAdapterMat(QVoid *A,
                                      const QInt idx_block_row,
                                      const QInt idx_block_col,
                                      QVoid **f_A)
{
    CmplxMat *A_adapter;
    QErrorCode ierr;
    ierr = QcMatGetAdapterMat(A, idx_block_row, idx_block_col, &A_adapter);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatGetAdapterMat");
    ierr = AdapterMatGetExternalMat(A_adapter, f_A);
    A_adapter = NULL;
    return ierr;
}
#elif defined(ADAPTER_REAL_MAT)
QErrorCode f03_api_QcMatSetAdapterMat(QVoid *A,
                                      const QInt idx_block_row,
                                      const QInt idx_block_col,
                                      const QInt data_type,
                                      QVoid **f_A)
{
    RealMat *A_adapter;
    /* defined data types, to be consistent with include/api/qcmatrix_f_mat_data.h90 */
    QcDataType def_data_type[4]={QIMAGMAT,QCMPLXMAT,QREALMAT,QNULLMAT};
    QErrorCode ierr;
    ierr = QcMatSetAdapterMat(A,
                              idx_block_row,
                              idx_block_col,
                              def_data_type[data_type+1],
                              &A_adapter);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatSetAdapterMat");
    ierr = AdapterMatSetExternalMat(A_adapter, f_A);
    A_adapter = NULL;
    return ierr;
}

QErrorCode f03_api_QcMatGetAdapterMat(QVoid *A,
                                      const QInt idx_block_row,
                                      const QInt idx_block_col,
                                      const QInt data_type,
                                      QVoid **f_A)
{
    RealMat *A_adapter;
    /* defined data types, to be consistent with include/api/qcmatrix_f_mat_data.h90 */
    QcDataType def_data_type[4]={QIMAGMAT,QCMPLXMAT,QREALMAT,QNULLMAT};
    QErrorCode ierr;
    ierr = QcMatGetAdapterMat(A,
                              idx_block_row,
                              idx_block_col,
                              def_data_type[data_type+1],
                              &A_adapter);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatGetAdapterMat");
    ierr = AdapterMatGetExternalMat(A_adapter, f_A);
    A_adapter = NULL;
    return ierr;
}
#endif
#endif

QErrorCode f03_api_QcMatSetRandMat(QVoid *A,
                                   const QInt sym_type,
                                   const QInt data_type,
                                   const QInt dim_block,
                                   const QInt num_row,
                                   const QInt num_col)
{
    /* defined symmetry types, to be consistent with include/api/qcmatrix_f_mat_symmetry.h90 */
    QcSymType def_sym_type[3]={QANTISYMMAT,QNONSYMMAT,QSYMMAT};
    /* defined data types, to be consistent with include/api/qcmatrix_f_mat_data.h90 */
    QcDataType def_data_type[4]={QIMAGMAT,QCMPLXMAT,QREALMAT,QNULLMAT};
    QErrorCode ierr;
    ierr = QcMatSetRandMat(A,
                           def_sym_type[sym_type+1],
                           def_data_type[data_type+1],
                           dim_block,
                           num_row,
                           num_col);
    return ierr;
}

QErrorCode f03_api_QcMatIsEqual(QVoid *A,
                                QVoid *B,
                                const QInt cf_values,
                                QInt *is_equal)
{
    /* Boolean type, to be consistent with
       include/api/qcmatrix_f_boolean.h90 and include/types/qcmatrix_basic_types.h */
    QBool c_Boolean[2]={QFALSE,QTRUE};
    QInt f_Boolean[2]={0,1};
    QBool c_is_equal;
    QErrorCode ierr;
    ierr = QcMatIsEqual(A, B, c_Boolean[cf_values], &c_is_equal);
    *is_equal = f_Boolean[c_is_equal];
    return ierr;
}

QErrorCode f03_api_QcMatCfArray(QVoid *A,
                                const QInt row_major,
                                const QInt size_values,
                                const QReal *values_real,
                                const QReal *values_imag,
                                QInt *is_equal)
{
    /* Boolean type, to be consistent with
       include/api/qcmatrix_f_boolean.h90 and include/types/qcmatrix_basic_types.h */
    QBool c_Boolean[2]={QFALSE,QTRUE};
    QInt f_Boolean[2]={0,1};
    QBool c_is_equal;
    QErrorCode ierr;
    ierr = QcMatCfArray(A,
                        c_Boolean[row_major],
                        size_values,
                        values_real,
                        values_imag,
                        &c_is_equal);
    *is_equal = f_Boolean[c_is_equal];
    return ierr;
}

QErrorCode f03_api_QcMatGetAllValues(QVoid *A,
                                     const QInt row_major,
                                     const QInt size_values,
                                     QReal *values_real,
                                     QReal *values_imag)
{
    /* Boolean type, to be consistent with
       include/api/qcmatrix_f_boolean.h90 and include/types/qcmatrix_basic_types.h */
    QBool c_Boolean[2]={QFALSE,QTRUE};
    QErrorCode ierr;
    ierr = QcMatGetAllValues(A,
                             c_Boolean[row_major],
                             size_values,
                             values_real,
                             values_imag);
    return ierr;
}
