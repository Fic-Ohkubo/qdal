!!  QcMatrix: an abstract matrix library
!!  Copyright 2012-2015 Bin Gao
!!
!!  QcMatrix is free software: you can redistribute it and/or modify
!!  it under the terms of the GNU Lesser General Public License as published by
!!  the Free Software Foundation, either version 3 of the License, or
!!  (at your option) any later version.
!!
!!  QcMatrix is distributed in the hope that it will be useful,
!!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
!!  GNU Lesser General Public License for more details.
!!
!!  You should have received a copy of the GNU Lesser General Public License
!!  along with QcMatrix. If not, see <http://www.gnu.org/licenses/>.
!!
!!  This file defines the QcMat type for the Fortran 2003 APIs.
!!
!!  2014-03-11, Bin Gao:
!!  * generated by tools/qcmatrix_fortran.py

! data types between C/Fortran
#include "api/qcmatrix_c_type.h"

module qcmatrix_f
    use, intrinsic :: iso_c_binding
    implicit none

    ! QcMat type (inspired by http://wiki.rac.manchester.ac.uk/community/GPU/GpuFaq/FortranGPU)
    type, public :: QcMat
        private
        type(C_PTR) :: c_mat = C_NULL_PTR
    end type QcMat

! parameters defined in QcMatrix library that will be used in Fortran APIs
#include "api/qcmatrix_f_api.h90"

    ! functions provided by the Fortran 2003 APIs
    public :: QcMatCreate_f
    public :: QcMatDestroy_f
    public :: QcMatBlockCreate_f
    public :: QcMatSetSymType_f
    public :: QcMatSetDataType_f
    public :: QcMatSetDimMat_f
#if defined(QCMATRIX_STORAGE_MODE)
    public :: QcMatSetStorageMode_f
#endif
    public :: QcMatAssemble_f
    public :: QcMatGetDimBlock_f
    public :: QcMatGetSymType_f
    public :: QcMatGetDataType_f
    public :: QcMatGetDimMat_f
#if defined(QCMATRIX_STORAGE_MODE)
    public :: QcMatGetStorageMode_f
#endif
    public :: QcMatIsAssembled_f
    public :: QcMatSetValues_f
    public :: QcMatAddValues_f
    public :: QcMatGetValues_f
    public :: QcMatDuplicate_f
    public :: QcMatZeroEntries_f
    public :: QcMatGetTrace_f
    public :: QcMatGetMatProdTrace_f
#if defined(QCMATRIX_ENABLE_VIEW)
    public :: QcMatWrite_f
    public :: QcMatRead_f
#endif
    public :: QcMatScale_f
    public :: QcMatAXPY_f
    public :: QcMatTranspose_f
    public :: QcMatGEMM_f
#if defined(ADAPTER_F03_LANG)
    public :: QcMatSetExternalMat_f
    public :: QcMatGetExternalMat_f
#endif
    public :: QcMatMatCommutator_f
    public :: QcMatMatSCommutator_f
    public :: QcMatMatHermCommutator_f
    public :: QcMatMatSHermCommutator_f
    public :: QcMatSetRandMat_f
    public :: QcMatIsEqual_f
    public :: QcMatCfArray_f
    public :: QcMatGetAllValues_f

    public :: QcMat_C_F_POINTER
    public :: QcMat_C_NULL_PTR
    public :: QcMat_C_LOC

    interface
        integer(C_INT) function f03_api_QcMatCreate(A) &
            bind(C, name="f03_api_QcMatCreate")
            use, intrinsic :: iso_c_binding
            type(C_PTR), intent(out) :: A
        end function f03_api_QcMatCreate
        integer(C_INT) function f03_api_QcMatDestroy(A) &
            bind(C, name="f03_api_QcMatDestroy")
            use, intrinsic :: iso_c_binding
            type(C_PTR), intent(inout) :: A
        end function f03_api_QcMatDestroy
        integer(C_INT) function QcMatBlockCreate(A, dim_block) &
            bind(C, name="QcMatBlockCreate")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            integer(kind=C_QINT), value, intent(in) :: dim_block
        end function QcMatBlockCreate
        integer(C_INT) function f03_api_QcMatSetSymType(A, sym_type) &
            bind(C, name="f03_api_QcMatSetSymType")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            integer(kind=C_QINT), value, intent(in) :: sym_type
        end function f03_api_QcMatSetSymType
        integer(C_INT) function f03_api_QcMatSetDataType(A,             &
                                                         num_blocks,    &
                                                         idx_block_row, &
                                                         idx_block_col, &
                                                         data_type)     &
            bind(C, name="f03_api_QcMatSetDataType")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            integer(kind=C_QINT), value, intent(in) :: num_blocks
            integer(kind=C_QINT), intent(in) :: idx_block_row(num_blocks)
            integer(kind=C_QINT), intent(in) :: idx_block_col(num_blocks)
            integer(kind=C_QINT), intent(in) :: data_type(num_blocks)
        end function f03_api_QcMatSetDataType
        integer(C_INT) function QcMatSetDimMat(A, num_row, num_col) &
            bind(C, name="QcMatSetDimMat")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            integer(kind=C_QINT), value, intent(in) :: num_row
            integer(kind=C_QINT), value, intent(in) :: num_col
        end function QcMatSetDimMat
#if defined(QCMATRIX_STORAGE_MODE)
        integer(C_INT) function f03_api_QcMatSetStorageMode(A, storage_mode) &
            bind(C, name="f03_api_QcMatSetStorageMode")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            integer(kind=C_QINT), value, intent(in) :: storage_mode
        end function f03_api_QcMatSetStorageMode
#endif
        integer(C_INT) function QcMatAssemble(A) &
            bind(C, name="QcMatAssemble")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
        end function QcMatAssemble
        integer(C_INT) function QcMatGetDimBlock(A, dim_block) &
            bind(C, name="QcMatGetDimBlock")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            integer(kind=C_QINT), intent(out) :: dim_block
        end function QcMatGetDimBlock
        integer(C_INT) function f03_api_QcMatGetSymType(A, sym_type) &
            bind(C, name="f03_api_QcMatGetSymType")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            integer(kind=C_QINT), intent(out) :: sym_type
        end function f03_api_QcMatGetSymType
        integer(C_INT) function f03_api_QcMatGetDataType(A,             &
                                                         num_blocks,    &
                                                         idx_block_row, &
                                                         idx_block_col, &
                                                         data_type)     &
            bind(C, name="f03_api_QcMatGetDataType")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            integer(kind=C_QINT), value, intent(in) :: num_blocks
            integer(kind=C_QINT), intent(in) :: idx_block_row(num_blocks)
            integer(kind=C_QINT), intent(in) :: idx_block_col(num_blocks)
            integer(kind=C_QINT), intent(out) :: data_type(num_blocks)
        end function f03_api_QcMatGetDataType
        integer(C_INT) function QcMatGetDimMat(A, num_row, num_col) &
            bind(C, name="QcMatGetDimMat")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            integer(kind=C_QINT), intent(out) :: num_row
            integer(kind=C_QINT), intent(out) :: num_col
        end function QcMatGetDimMat
#if defined(QCMATRIX_STORAGE_MODE)
        integer(C_INT) function f03_api_QcMatGetStorageMode(A, storage_mode) &
            bind(C, name="f03_api_QcMatGetStorageMode")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            integer(kind=C_QINT), intent(out) :: storage_mode
        end function f03_api_QcMatGetStorageMode
#endif
        integer(C_INT) function f03_api_QcMatIsAssembled(A, assembled) &
            bind(C, name="f03_api_QcMatIsAssembled")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            integer(kind=C_QINT), intent(out) :: assembled
        end function f03_api_QcMatIsAssembled
        integer(C_INT) function f03_api_QcMatSetRealValues(A,             &
                                                           idx_block_row, &
                                                           idx_block_col, &
                                                           idx_first_row, &
                                                           num_row_set,   &
                                                           idx_first_col, &
                                                           num_col_set,   &
                                                           values_real)   &
            bind(C, name="f03_api_QcMatSetRealValues")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            integer(kind=C_QINT), value, intent(in) :: idx_block_row
            integer(kind=C_QINT), value, intent(in) :: idx_block_col
            integer(kind=C_QINT), value, intent(in) :: idx_first_row
            integer(kind=C_QINT), value, intent(in) :: num_row_set
            integer(kind=C_QINT), value, intent(in) :: idx_first_col
            integer(kind=C_QINT), value, intent(in) :: num_col_set
            real(kind=C_QREAL), intent(in) :: values_real(num_row_set*num_col_set)
        end function f03_api_QcMatSetRealValues
        integer(C_INT) function f03_api_QcMatSetImagValues(A,             &
                                                           idx_block_row, &
                                                           idx_block_col, &
                                                           idx_first_row, &
                                                           num_row_set,   &
                                                           idx_first_col, &
                                                           num_col_set,   &
                                                           values_imag)   &
            bind(C, name="f03_api_QcMatSetImagValues")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            integer(kind=C_QINT), value, intent(in) :: idx_block_row
            integer(kind=C_QINT), value, intent(in) :: idx_block_col
            integer(kind=C_QINT), value, intent(in) :: idx_first_row
            integer(kind=C_QINT), value, intent(in) :: num_row_set
            integer(kind=C_QINT), value, intent(in) :: idx_first_col
            integer(kind=C_QINT), value, intent(in) :: num_col_set
            real(kind=C_QREAL), intent(in) :: values_imag(num_row_set*num_col_set)
        end function f03_api_QcMatSetImagValues
        integer(C_INT) function f03_api_QcMatAddRealValues(A,             &
                                                           idx_block_row, &
                                                           idx_block_col, &
                                                           idx_first_row, &
                                                           num_row_add,   &
                                                           idx_first_col, &
                                                           num_col_add,   &
                                                           values_real)   &
            bind(C, name="f03_api_QcMatAddRealValues")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            integer(kind=C_QINT), value, intent(in) :: idx_block_row
            integer(kind=C_QINT), value, intent(in) :: idx_block_col
            integer(kind=C_QINT), value, intent(in) :: idx_first_row
            integer(kind=C_QINT), value, intent(in) :: num_row_add
            integer(kind=C_QINT), value, intent(in) :: idx_first_col
            integer(kind=C_QINT), value, intent(in) :: num_col_add
            real(kind=C_QREAL), intent(in) :: values_real(num_row_add*num_col_add)
        end function f03_api_QcMatAddRealValues
        integer(C_INT) function f03_api_QcMatAddImagValues(A,             &
                                                           idx_block_row, &
                                                           idx_block_col, &
                                                           idx_first_row, &
                                                           num_row_add,   &
                                                           idx_first_col, &
                                                           num_col_add,   &
                                                           values_imag)   &
            bind(C, name="f03_api_QcMatAddImagValues")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            integer(kind=C_QINT), value, intent(in) :: idx_block_row
            integer(kind=C_QINT), value, intent(in) :: idx_block_col
            integer(kind=C_QINT), value, intent(in) :: idx_first_row
            integer(kind=C_QINT), value, intent(in) :: num_row_add
            integer(kind=C_QINT), value, intent(in) :: idx_first_col
            integer(kind=C_QINT), value, intent(in) :: num_col_add
            real(kind=C_QREAL), intent(in) :: values_imag(num_row_add*num_col_add)
        end function f03_api_QcMatAddImagValues
        integer(C_INT) function f03_api_QcMatGetRealValues(A,             &
                                                           idx_block_row, &
                                                           idx_block_col, &
                                                           idx_first_row, &
                                                           num_row_get,   &
                                                           idx_first_col, &
                                                           num_col_get,   &
                                                           values_real)   &
            bind(C, name="f03_api_QcMatGetRealValues")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            integer(kind=C_QINT), value, intent(in) :: idx_block_row
            integer(kind=C_QINT), value, intent(in) :: idx_block_col
            integer(kind=C_QINT), value, intent(in) :: idx_first_row
            integer(kind=C_QINT), value, intent(in) :: num_row_get
            integer(kind=C_QINT), value, intent(in) :: idx_first_col
            integer(kind=C_QINT), value, intent(in) :: num_col_get
            real(kind=C_QREAL), intent(out) :: values_real(num_row_get*num_col_get)
        end function f03_api_QcMatGetRealValues
        integer(C_INT) function f03_api_QcMatGetImagValues(A,             &
                                                           idx_block_row, &
                                                           idx_block_col, &
                                                           idx_first_row, &
                                                           num_row_get,   &
                                                           idx_first_col, &
                                                           num_col_get,   &
                                                           values_imag)   &
            bind(C, name="f03_api_QcMatGetImagValues")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            integer(kind=C_QINT), value, intent(in) :: idx_block_row
            integer(kind=C_QINT), value, intent(in) :: idx_block_col
            integer(kind=C_QINT), value, intent(in) :: idx_first_row
            integer(kind=C_QINT), value, intent(in) :: num_row_get
            integer(kind=C_QINT), value, intent(in) :: idx_first_col
            integer(kind=C_QINT), value, intent(in) :: num_col_get
            real(kind=C_QREAL), intent(out) :: values_imag(num_row_get*num_col_get)
        end function f03_api_QcMatGetImagValues
        integer(C_INT) function f03_api_QcMatDuplicate(A, duplicate_option, B) &
            bind(C, name="f03_api_QcMatDuplicate")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            integer(kind=C_QINT), value, intent(in) :: duplicate_option
            type(C_PTR), value, intent(in) :: B
        end function f03_api_QcMatDuplicate
        integer(C_INT) function QcMatZeroEntries(A) &
            bind(C, name="QcMatZeroEntries")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
        end function QcMatZeroEntries
        integer(C_INT) function QcMatGetTrace(A, num_blocks, trace) &
            bind(C, name="QcMatGetTrace")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            integer(kind=C_QINT), value, intent(in) :: num_blocks
            real(kind=C_QREAL), intent(out) :: trace(2*num_blocks)
        end function QcMatGetTrace
        integer(C_INT) function f03_api_QcMatGetMatProdTrace(A, B, op_B, num_blocks, trace) &
            bind(C, name="f03_api_QcMatGetMatProdTrace")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            type(C_PTR), value, intent(in) :: B
            integer(kind=C_QINT), value, intent(in) :: op_B
            integer(kind=C_QINT), value, intent(in) :: num_blocks
            real(kind=C_QREAL), intent(out) :: trace(2*num_blocks)
        end function f03_api_QcMatGetMatProdTrace
#if defined(QCMATRIX_ENABLE_VIEW)
        integer(C_INT) function f03_api_QcMatWrite(A, mat_label, view_option) &
            bind(C, name="f03_api_QcMatWrite")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            character(C_CHAR), intent(in) :: mat_label(*)
            integer(kind=C_QINT), value, intent(in) :: view_option
        end function f03_api_QcMatWrite
        integer(C_INT) function f03_api_QcMatRead(A, mat_label, view_option) &
            bind(C, name="f03_api_QcMatRead")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            character(C_CHAR), intent(in) :: mat_label(*)
            integer(kind=C_QINT), value, intent(in) :: view_option
        end function f03_api_QcMatRead
#endif
        integer(C_INT) function QcMatScale(scal_number, A) &
            bind(C, name="QcMatScale")
            use, intrinsic :: iso_c_binding
            real(kind=C_QREAL), intent(in) :: scal_number(2)
            type(C_PTR), value, intent(in) :: A
        end function QcMatScale
        integer(C_INT) function QcMatAXPY(multiplier, X, Y) &
            bind(C, name="QcMatAXPY")
            use, intrinsic :: iso_c_binding
            real(kind=C_QREAL), intent(in) :: multiplier(2)
            type(C_PTR), value, intent(in) :: X
            type(C_PTR), value, intent(in) :: Y
        end function QcMatAXPY
        integer(C_INT) function f03_api_QcMatTranspose(op_A, A, B) &
            bind(C, name="f03_api_QcMatTranspose")
            use, intrinsic :: iso_c_binding
            integer(kind=C_QINT), value, intent(in) :: op_A
            type(C_PTR), value, intent(in) :: A
            type(C_PTR), value, intent(in) :: B
        end function f03_api_QcMatTranspose
        integer(C_INT) function f03_api_QcMatGEMM(op_A, op_B, alpha, A, B, beta, C) &
            bind(C, name="f03_api_QcMatGEMM")
            use, intrinsic :: iso_c_binding
            integer(kind=C_QINT), value, intent(in) :: op_A
            integer(kind=C_QINT), value, intent(in) :: op_B
            real(kind=C_QREAL), intent(in) :: alpha(2)
            type(C_PTR), value, intent(in) :: A
            type(C_PTR), value, intent(in) :: B
            real(kind=C_QREAL), intent(in) :: beta(2)
            type(C_PTR), value, intent(in) :: C
        end function f03_api_QcMatGEMM
#if defined(ADAPTER_F03_LANG)
#if defined(ADAPTER_BLOCK_CMPLX)
        integer(C_INT) function AdapterMatSetExternalMat(A, c_A) &
            bind(C, name="AdapterMatSetExternalMat")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            type(C_PTR), intent(in) :: c_A
        end function AdapterMatSetExternalMat
        integer(C_INT) function AdapterMatGetExternalMat(A, c_A) &
            bind(C, name="AdapterMatGetExternalMat")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            type(C_PTR), intent(inout) :: c_A
        end function AdapterMatGetExternalMat
#elif defined(ADAPTER_BLOCK_REAL)
        integer(C_INT) function f03_api_QcMatSetAdapterMat(A, data_type, c_A) &
            bind(C, name="f03_api_QcMatSetAdapterMat")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            integer(kind=C_QINT), value, intent(in) :: data_type
            type(C_PTR), intent(in) :: c_A
        end function f03_api_QcMatSetAdapterMat
        integer(C_INT) function f03_api_QcMatGetAdapterMat(A, data_type, c_A) &
            bind(C, name="f03_api_QcMatGetAdapterMat")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            integer(kind=C_QINT), value, intent(in) :: data_type
            type(C_PTR), intent(inout) :: c_A
        end function f03_api_QcMatGetAdapterMat
#elif defined(ADAPTER_CMPLX_MAT)
        integer(C_INT) function f03_api_QcMatSetAdapterMat(A,             &
                                                           idx_block_row, &
                                                           idx_block_col, &
                                                           c_A)           &
            bind(C, name="f03_api_QcMatSetAdapterMat")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            integer(kind=C_QINT), value, intent(in) :: idx_block_row
            integer(kind=C_QINT), value, intent(in) :: idx_block_col
            type(C_PTR), intent(in) :: c_A
        end function f03_api_QcMatSetAdapterMat
        integer(C_INT) function f03_api_QcMatGetAdapterMat(A,             &
                                                           idx_block_row, &
                                                           idx_block_col, &
                                                           c_A)           &
            bind(C, name="f03_api_QcMatGetAdapterMat")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            integer(kind=C_QINT), value, intent(in) :: idx_block_row
            integer(kind=C_QINT), value, intent(in) :: idx_block_col
            type(C_PTR), intent(inout) :: c_A
        end function f03_api_QcMatGetAdapterMat
#elif defined(ADAPTER_REAL_MAT)
        integer(C_INT) function f03_api_QcMatSetAdapterMat(A,             &
                                                           idx_block_row, &
                                                           idx_block_col, &
                                                           data_type,     &
                                                           c_A)           &
            bind(C, name="f03_api_QcMatSetAdapterMat")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            integer(kind=C_QINT), value, intent(in) :: idx_block_row
            integer(kind=C_QINT), value, intent(in) :: idx_block_col
            integer(kind=C_QINT), value, intent(in) :: data_type
            type(C_PTR), intent(in) :: c_A
        end function f03_api_QcMatSetAdapterMat
        integer(C_INT) function f03_api_QcMatGetAdapterMat(A,             &
                                                           idx_block_row, &
                                                           idx_block_col, &
                                                           data_type,     &
                                                           c_A)           &
            bind(C, name="f03_api_QcMatGetAdapterMat")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            integer(kind=C_QINT), value, intent(in) :: idx_block_row
            integer(kind=C_QINT), value, intent(in) :: idx_block_col
            integer(kind=C_QINT), value, intent(in) :: data_type
            type(C_PTR), intent(inout) :: c_A
        end function f03_api_QcMatGetAdapterMat
#endif
#endif
        integer(C_INT) function QcMatMatCommutator(A, B, C) &
            bind(C, name="QcMatMatCommutator")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            type(C_PTR), value, intent(in) :: B
            type(C_PTR), value, intent(in) :: C
        end function QcMatMatCommutator
        integer(C_INT) function QcMatMatSCommutator(A, B, S, C) &
            bind(C, name="QcMatMatSCommutator")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            type(C_PTR), value, intent(in) :: B
            type(C_PTR), value, intent(in) :: S
            type(C_PTR), value, intent(in) :: C
        end function QcMatMatSCommutator
        integer(C_INT) function QcMatMatHermCommutator(A, B, C) &
            bind(C, name="QcMatMatHermCommutator")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            type(C_PTR), value, intent(in) :: B
            type(C_PTR), value, intent(in) :: C
        end function QcMatMatHermCommutator
        integer(C_INT) function QcMatMatSHermCommutator(A, B, S, C) &
            bind(C, name="QcMatMatSHermCommutator")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            type(C_PTR), value, intent(in) :: B
            type(C_PTR), value, intent(in) :: S
            type(C_PTR), value, intent(in) :: C
        end function QcMatMatSHermCommutator
        integer(C_INT) function f03_api_QcMatSetRandMat(A,         &
                                                        sym_type,  &
                                                        data_type, &
                                                        dim_block, &
                                                        num_row,   &
                                                        num_col)   &
            bind(C, name="f03_api_QcMatSetRandMat")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            integer(kind=C_QINT), value, intent(in) :: sym_type
            integer(kind=C_QINT), value, intent(in) :: data_type
            integer(kind=C_QINT), value, intent(in) :: dim_block
            integer(kind=C_QINT), value, intent(in) :: num_row
            integer(kind=C_QINT), value, intent(in) :: num_col
        end function f03_api_QcMatSetRandMat
        integer(C_INT) function f03_api_QcMatIsEqual(A, B, cf_values, is_equal) &
            bind(C, name="f03_api_QcMatIsEqual")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            type(C_PTR), value, intent(in) :: B
            integer(kind=C_QINT), value, intent(in) :: cf_values
            integer(kind=C_QINT), intent(out) :: is_equal
        end function f03_api_QcMatIsEqual
        integer(C_INT) function f03_api_QcMatCfArray(A,           &
                                                     row_major,   &
                                                     size_values, &
                                                     values_real, &
                                                     values_imag, &
                                                     is_equal)    &
            bind(C, name="f03_api_QcMatCfArray")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            integer(kind=C_QINT), value, intent(in) :: row_major
            integer(kind=C_QINT), value, intent(in) :: size_values
            real(kind=C_QREAL), intent(in) :: values_real(size_values)
            real(kind=C_QREAL), intent(in) :: values_imag(size_values)
            integer(kind=C_QINT), intent(out) :: is_equal
        end function f03_api_QcMatCfArray
        integer(C_INT) function f03_api_QcMatGetAllValues(A,           &
                                                          row_major,   &
                                                          size_values, &
                                                          values_real, &
                                                          values_imag) &
            bind(C, name="f03_api_QcMatGetAllValues")
            use, intrinsic :: iso_c_binding
            type(C_PTR), value, intent(in) :: A
            integer(kind=C_QINT), value, intent(in) :: row_major
            integer(kind=C_QINT), value, intent(in) :: size_values
            real(kind=C_QREAL), intent(out) :: values_real(size_values)
            real(kind=C_QREAL), intent(out) :: values_imag(size_values)
        end function f03_api_QcMatGetAllValues
    end interface

    contains

    function QcMatCreate_f(A) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(out) :: A
        ierr = f03_api_QcMatCreate(A%c_mat)
    end function QcMatCreate_f

    function QcMatDestroy_f(A) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(inout) :: A
        ierr = f03_api_QcMatDestroy(A%c_mat)
    end function QcMatDestroy_f

    function QcMatBlockCreate_f(A, dim_block) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(in) :: dim_block
        ierr = QcMatBlockCreate(A%c_mat, dim_block)
    end function QcMatBlockCreate_f

    function QcMatSetSymType_f(A, sym_type) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(in) :: sym_type
        ierr = f03_api_QcMatSetSymType(A%c_mat, sym_type)
    end function QcMatSetSymType_f

    function QcMatSetDataType_f(A,             &
                                num_blocks,    &
                                idx_block_row, &
                                idx_block_col, &
                                data_type) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(in) :: num_blocks
        integer(kind=QINT), intent(in) :: idx_block_row(num_blocks)
        integer(kind=QINT), intent(in) :: idx_block_col(num_blocks)
        integer(kind=QINT), intent(in) :: data_type(num_blocks)
        ierr = f03_api_QcMatSetDataType(A%c_mat,       &
                                        num_blocks,    &
                                        idx_block_row, &
                                        idx_block_col, &
                                        data_type)
    end function QcMatSetDataType_f

    function QcMatSetDimMat_f(A, num_row, num_col) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(in) :: num_row
        integer(kind=QINT), intent(in) :: num_col
        ierr = QcMatSetDimMat(A%c_mat, num_row, num_col)
    end function QcMatSetDimMat_f

#if defined(QCMATRIX_STORAGE_MODE)
    function QcMatSetStorageMode_f(A, storage_mode) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(in) :: storage_mode
        ierr = f03_api_QcMatSetStorageMode(A%c_mat, storage_mode)
    end function QcMatSetStorageMode_f
#endif

    function QcMatAssemble_f(A) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        ierr = QcMatAssemble(A%c_mat)
    end function QcMatAssemble_f

    function QcMatGetDimBlock_f(A, dim_block) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(out) :: dim_block
        ierr = QcMatGetDimBlock(A%c_mat, dim_block)
    end function QcMatGetDimBlock_f

    function QcMatGetSymType_f(A, sym_type) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(out) :: sym_type
        ierr = f03_api_QcMatGetSymType(A%c_mat, sym_type)
    end function QcMatGetSymType_f

    function QcMatGetDataType_f(A,             &
                                num_blocks,    &
                                idx_block_row, &
                                idx_block_col, &
                                data_type) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(in) :: num_blocks
        integer(kind=QINT), intent(in) :: idx_block_row(num_blocks)
        integer(kind=QINT), intent(in) :: idx_block_col(num_blocks)
        integer(kind=QINT), intent(out) :: data_type(num_blocks)
        ierr = f03_api_QcMatGetDataType(A%c_mat,       &
                                        num_blocks,    &
                                        idx_block_row, &
                                        idx_block_col, &
                                        data_type)
    end function QcMatGetDataType_f

    function QcMatGetDimMat_f(A, num_row, num_col) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(out) :: num_row
        integer(kind=QINT), intent(out) :: num_col
        ierr = QcMatGetDimMat(A%c_mat, num_row, num_col)
    end function QcMatGetDimMat_f

#if defined(QCMATRIX_STORAGE_MODE)
    function QcMatGetStorageMode_f(A, storage_mode) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(out) :: storage_mode
        ierr = f03_api_QcMatGetStorageMode(A%c_mat, storage_mode)
    end function QcMatGetStorageMode_f
#endif

    function QcMatIsAssembled_f(A, assembled) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        logical(kind=4), intent(out) :: assembled
        integer(kind=QINT) c_assembled
        ierr = f03_api_QcMatIsAssembled(A%c_mat, c_assembled)
        if (c_assembled==QTRUE) then
            assembled = .true.
        else
            assembled = .false.
        end if
    end function QcMatIsAssembled_f

    function QcMatSetValues_f(A,             &
                              idx_block_row, &
                              idx_block_col, &
                              idx_first_row, &
                              num_row_set,   &
                              idx_first_col, &
                              num_col_set,   &
                              values_real,   &
                              values_imag) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(in) :: idx_block_row
        integer(kind=QINT), intent(in) :: idx_block_col
        integer(kind=QINT), intent(in) :: idx_first_row
        integer(kind=QINT), intent(in) :: num_row_set
        integer(kind=QINT), intent(in) :: idx_first_col
        integer(kind=QINT), intent(in) :: num_col_set
        real(kind=QREAL), optional, intent(in) :: values_real(num_row_set*num_col_set)
        real(kind=QREAL), optional, intent(in) :: values_imag(num_row_set*num_col_set)
        if (present(values_real)) then
            ierr = f03_api_QcMatSetRealValues(A%c_mat,       &
                                              idx_block_row, &
                                              idx_block_col, &
                                              idx_first_row, &
                                              num_row_set,   &
                                              idx_first_col, &
                                              num_col_set,   &
                                              values_real)
        end if
        if (present(values_imag)) then
            ierr = f03_api_QcMatSetImagValues(A%c_mat,       &
                                              idx_block_row, &
                                              idx_block_col, &
                                              idx_first_row, &
                                              num_row_set,   &
                                              idx_first_col, &
                                              num_col_set,   &
                                              values_imag)
        end if
    end function QcMatSetValues_f

    function QcMatAddValues_f(A,             &
                              idx_block_row, &
                              idx_block_col, &
                              idx_first_row, &
                              num_row_add,   &
                              idx_first_col, &
                              num_col_add,   &
                              values_real,   &
                              values_imag) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(in) :: idx_block_row
        integer(kind=QINT), intent(in) :: idx_block_col
        integer(kind=QINT), intent(in) :: idx_first_row
        integer(kind=QINT), intent(in) :: num_row_add
        integer(kind=QINT), intent(in) :: idx_first_col
        integer(kind=QINT), intent(in) :: num_col_add
        real(kind=QREAL), optional, intent(in) :: values_real(num_row_add*num_col_add)
        real(kind=QREAL), optional, intent(in) :: values_imag(num_row_add*num_col_add)
        if (present(values_real)) then
            ierr = f03_api_QcMatAddRealValues(A%c_mat,       &
                                              idx_block_row, &
                                              idx_block_col, &
                                              idx_first_row, &
                                              num_row_add,   &
                                              idx_first_col, &
                                              num_col_add,   &
                                              values_real)
        end if
        if (present(values_imag)) then
            ierr = f03_api_QcMatAddImagValues(A%c_mat,       &
                                              idx_block_row, &
                                              idx_block_col, &
                                              idx_first_row, &
                                              num_row_add,   &
                                              idx_first_col, &
                                              num_col_add,   &
                                              values_imag)
        end if
    end function QcMatAddValues_f

    function QcMatGetValues_f(A,             &
                              idx_block_row, &
                              idx_block_col, &
                              idx_first_row, &
                              num_row_get,   &
                              idx_first_col, &
                              num_col_get,   &
                              values_real,   &
                              values_imag) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(in) :: idx_block_row
        integer(kind=QINT), intent(in) :: idx_block_col
        integer(kind=QINT), intent(in) :: idx_first_row
        integer(kind=QINT), intent(in) :: num_row_get
        integer(kind=QINT), intent(in) :: idx_first_col
        integer(kind=QINT), intent(in) :: num_col_get
        real(kind=QREAL), optional, intent(out) :: values_real(num_row_get*num_col_get)
        real(kind=QREAL), optional, intent(out) :: values_imag(num_row_get*num_col_get)
        if (present(values_real)) then
            ierr = f03_api_QcMatGetRealValues(A%c_mat,       &
                                              idx_block_row, &
                                              idx_block_col, &
                                              idx_first_row, &
                                              num_row_get,   &
                                              idx_first_col, &
                                              num_col_get,   &
                                              values_real)
        end if
        if (present(values_imag)) then
            ierr = f03_api_QcMatGetImagValues(A%c_mat,       &
                                              idx_block_row, &
                                              idx_block_col, &
                                              idx_first_row, &
                                              num_row_get,   &
                                              idx_first_col, &
                                              num_col_get,   &
                                              values_imag)
        end if
    end function QcMatGetValues_f

    function QcMatDuplicate_f(A, duplicate_option, B) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(in) :: duplicate_option
        type(QcMat), intent(in) :: B
        ierr = f03_api_QcMatDuplicate(A%c_mat, duplicate_option, B%c_mat)
    end function QcMatDuplicate_f

    function QcMatZeroEntries_f(A) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        ierr = QcMatZeroEntries(A%c_mat)
    end function QcMatZeroEntries_f

    function QcMatGetTrace_f(A, num_blocks, trace) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(in) :: num_blocks
        real(kind=QREAL), intent(out) :: trace(2*num_blocks)
        ierr = QcMatGetTrace(A%c_mat, num_blocks, trace)
    end function QcMatGetTrace_f

    function QcMatGetMatProdTrace_f(A, B, op_B, num_blocks, trace) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        type(QcMat), intent(in) :: B
        integer(kind=QINT), intent(in) :: op_B
        integer(kind=QINT), intent(in) :: num_blocks
        real(kind=QREAL), intent(out) :: trace(2*num_blocks)
        ierr = f03_api_QcMatGetMatProdTrace(A%c_mat, B%c_mat, op_B, num_blocks, trace)
    end function QcMatGetMatProdTrace_f

#if defined(QCMATRIX_ENABLE_VIEW)
    function QcMatWrite_f(A, mat_label, view_option) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        character*(*), intent(in) :: mat_label
        integer(kind=QINT), intent(in) :: view_option
        ierr = f03_api_QcMatWrite(A%c_mat, mat_label//C_NULL_CHAR, view_option)
    end function QcMatWrite_f

    function QcMatRead_f(A, mat_label, view_option) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        character*(*), intent(in) :: mat_label
        integer(kind=QINT), intent(in) :: view_option
        ierr = f03_api_QcMatRead(A%c_mat, mat_label//C_NULL_CHAR, view_option)
    end function QcMatRead_f
#endif

    function QcMatScale_f(scal_number, A) result(ierr)
        integer(kind=4) :: ierr
        real(kind=QREAL), intent(in) :: scal_number(2)
        type(QcMat), intent(in) :: A
        ierr = QcMatScale(scal_number, A%c_mat)
    end function QcMatScale_f

    function QcMatAXPY_f(multiplier, X, Y) result(ierr)
        integer(kind=4) :: ierr
        real(kind=QREAL), intent(in) :: multiplier(2)
        type(QcMat), intent(in) :: X
        type(QcMat), intent(in) :: Y
        ierr = QcMatAXPY(multiplier, X%c_mat, Y%c_mat)
    end function QcMatAXPY_f

    function QcMatTranspose_f(op_A, A, B) result(ierr)
        integer(kind=4) :: ierr
        integer(kind=QINT), intent(in) :: op_A
        type(QcMat), intent(in) :: A
        type(QcMat), intent(in) :: B
        ierr = f03_api_QcMatTranspose(op_A, A%c_mat, B%c_mat)
    end function QcMatTranspose_f

    function QcMatGEMM_f(op_A, op_B, alpha, A, B, beta, C) result(ierr)
        integer(kind=4) :: ierr
        integer(kind=QINT), intent(in) :: op_A
        integer(kind=QINT), intent(in) :: op_B
        real(kind=QREAL), intent(in) :: alpha(2)
        type(QcMat), intent(in) :: A
        type(QcMat), intent(in) :: B
        real(kind=QREAL), intent(in) :: beta(2)
        type(QcMat), intent(in) :: C
        ierr = f03_api_QcMatGEMM(op_A, op_B, alpha, A%c_mat, B%c_mat, beta, C%c_mat)
    end function QcMatGEMM_f

#if defined(ADAPTER_F03_LANG)
! checks if the external Fortran module and matrix type are given
#include "adapter/check_f_mod.h"

#if defined(ADAPTER_BLOCK_CMPLX)
    function QcMatSetExternalMat_f(A, A_ext) result(ierr)
        use LANG_F_MODULE, only: LANG_F_MATRIX
        integer(kind=4) :: ierr
        type(QcMat), intent(inout) :: A
        type(LANG_F_MATRIX), pointer, intent(in) :: A_ext
        type(C_PTR) c_A
        c_A = c_loc(A_ext)
        ierr = AdapterMatSetExternalMat(A%c_mat, c_A)
    end function QcMatSetExternalMat_f

    function QcMatGetExternalMat_f(A, A_ext) result(ierr)
        use LANG_F_MODULE, only: LANG_F_MATRIX
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        type(LANG_F_MATRIX), pointer, intent(inout) :: A_ext
        type(C_PTR) c_A
        ierr = AdapterMatGetExternalMat(A%c_mat, c_A)
        call c_f_pointer(c_A, A_ext)
    end function QcMatGetExternalMat_f
#elif defined(ADAPTER_BLOCK_REAL)
    function QcMatSetExternalMat_f(A, data_type, A_ext) result(ierr)
        use LANG_F_MODULE, only: LANG_F_MATRIX
        integer(kind=4) :: ierr
        type(QcMat), intent(inout) :: A
        integer(kind=QINT), intent(in) :: data_type
        type(LANG_F_MATRIX), pointer, intent(in) :: A_ext
        type(C_PTR) c_A
        c_A = c_loc(A_ext)
        ierr = f03_api_QcMatSetAdapterMat(A%c_mat, data_type, c_A)
    end function QcMatSetExternalMat_f

    function QcMatGetExternalMat_f(A, data_type, A_ext) result(ierr)
        use LANG_F_MODULE, only: LANG_F_MATRIX
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(in) :: data_type
        type(LANG_F_MATRIX), pointer, intent(inout) :: A_ext
        type(C_PTR) c_A
        ierr = f03_api_QcMatGetAdapterMat(A%c_mat, data_type, c_A)
        call c_f_pointer(c_A, A_ext)
    end function QcMatGetExternalMat_f
#elif defined(ADAPTER_CMPLX_MAT)
    function QcMatSetExternalMat_f(A, idx_block_row, idx_block_col, A_ext) result(ierr)
        use LANG_F_MODULE, only: LANG_F_MATRIX
        integer(kind=4) :: ierr
        type(QcMat), intent(inout) :: A
        integer(kind=QINT), intent(in) :: idx_block_row
        integer(kind=QINT), intent(in) :: idx_block_col
        type(LANG_F_MATRIX), pointer, intent(in) :: A_ext
        type(C_PTR) c_A
        c_A = c_loc(A_ext)
        ierr = f03_api_QcMatSetAdapterMat(A%c_mat, idx_block_row, idx_block_col, c_A)
    end function QcMatSetExternalMat_f

    function QcMatGetExternalMat_f(A, idx_block_row, idx_block_col, A_ext) result(ierr)
        use LANG_F_MODULE, only: LANG_F_MATRIX
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(in) :: idx_block_row
        integer(kind=QINT), intent(in) :: idx_block_col
        type(LANG_F_MATRIX), pointer, intent(inout) :: A_ext
        type(C_PTR) c_A
        ierr = f03_api_QcMatGetAdapterMat(A%c_mat, idx_block_row, idx_block_col, c_A)
        call c_f_pointer(c_A, A_ext)
    end function QcMatGetExternalMat_f
#elif defined(ADAPTER_REAL_MAT)
    function QcMatSetExternalMat_f(A,             &
                                   idx_block_row, &
                                   idx_block_col, &
                                   data_type,     &
                                   A_ext) result(ierr)
        use LANG_F_MODULE, only: LANG_F_MATRIX
        integer(kind=4) :: ierr
        type(QcMat), intent(inout) :: A
        integer(kind=QINT), intent(in) :: idx_block_row
        integer(kind=QINT), intent(in) :: idx_block_col
        integer(kind=QINT), intent(in) :: data_type
        type(LANG_F_MATRIX), pointer, intent(in) :: A_ext
        type(C_PTR) c_A
        c_A = c_loc(A_ext)
        ierr = f03_api_QcMatSetAdapterMat(A%c_mat,       &
                                          idx_block_row, &
                                          idx_block_col, &
                                          data_type,     &
                                          c_A)
    end function QcMatSetExternalMat_f

    function QcMatGetExternalMat_f(A,             &
                                   idx_block_row, &
                                   idx_block_col, &
                                   data_type,     &
                                   A_ext) result(ierr)
        use LANG_F_MODULE, only: LANG_F_MATRIX
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(in) :: idx_block_row
        integer(kind=QINT), intent(in) :: idx_block_col
        integer(kind=QINT), intent(in) :: data_type
        type(LANG_F_MATRIX), pointer, intent(inout) :: A_ext
        type(C_PTR) c_A
        ierr = f03_api_QcMatGetAdapterMat(A%c_mat,       &
                                          idx_block_row, &
                                          idx_block_col, &
                                          data_type,     &
                                          c_A)
        call c_f_pointer(c_A, A_ext)
    end function QcMatGetExternalMat_f
#endif
#endif

    function QcMatMatCommutator_f(A, B, C) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        type(QcMat), intent(in) :: B
        type(QcMat), intent(in) :: C
        ierr = QcMatMatCommutator(A%c_mat, B%c_mat, C%c_mat)
    end function QcMatMatCommutator_f

    function QcMatMatSCommutator_f(A, B, S, C) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        type(QcMat), intent(in) :: B
        type(QcMat), intent(in) :: S
        type(QcMat), intent(in) :: C
        ierr = QcMatMatSCommutator(A%c_mat, B%c_mat, S%c_mat, C%c_mat)
    end function QcMatMatSCommutator_f

    function QcMatMatHermCommutator_f(A, B, C) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        type(QcMat), intent(in) :: B
        type(QcMat), intent(in) :: C
        ierr = QcMatMatHermCommutator(A%c_mat, B%c_mat, C%c_mat)
    end function QcMatMatHermCommutator_f

    function QcMatMatSHermCommutator_f(A, B, S, C) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        type(QcMat), intent(in) :: B
        type(QcMat), intent(in) :: S
        type(QcMat), intent(in) :: C
        ierr = QcMatMatSHermCommutator(A%c_mat, B%c_mat, S%c_mat, C%c_mat)
    end function QcMatMatSHermCommutator_f

    function QcMatSetRandMat_f(A,         &
                               sym_type,  &
                               data_type, &
                               dim_block, &
                               num_row,   &
                               num_col) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        integer(kind=QINT), intent(in) :: sym_type
        integer(kind=QINT), intent(in) :: data_type
        integer(kind=QINT), intent(in) :: dim_block
        integer(kind=QINT), intent(in) :: num_row
        integer(kind=QINT), intent(in) :: num_col
        ierr = f03_api_QcMatSetRandMat(A%c_mat,   &
                                       sym_type,  &
                                       data_type, &
                                       dim_block, &
                                       num_row,   &
                                       num_col)
    end function QcMatSetRandMat_f

    function QcMatIsEqual_f(A, B, cf_values, is_equal) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        type(QcMat), intent(in) :: B
        logical(kind=4), intent(in) :: cf_values
        logical(kind=4), intent(out) :: is_equal
        integer(kind=QINT) c_cf_values
        integer(kind=QINT) c_is_equal
        if (cf_values) then
            c_cf_values = QTRUE
        else
            c_cf_values = QFALSE
        end if
        ierr = f03_api_QcMatIsEqual(A%c_mat, B%c_mat, c_cf_values, c_is_equal)
        if (c_is_equal==QTRUE) then
            is_equal = .true.
        else
            is_equal = .false.
        end if
    end function QcMatIsEqual_f

    function QcMatCfArray_f(A,           &
                            row_major,   &
                            size_values, &
                            values_real, &
                            values_imag, &
                            is_equal) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        logical(kind=4), intent(in) :: row_major
        integer(kind=QINT), intent(in) :: size_values
        real(kind=QREAL), intent(in) :: values_real(size_values)
        real(kind=QREAL), intent(in) :: values_imag(size_values)
        logical(kind=4), intent(out) :: is_equal
        integer(kind=QINT) c_row_major
        integer(kind=QINT) c_is_equal
        if (row_major) then
            c_row_major = QTRUE
        else
            c_row_major = QFALSE
        end if
        ierr = f03_api_QcMatCfArray(A%c_mat,     &
                                    c_row_major, &
                                    size_values, &
                                    values_real, &
                                    values_imag, &
                                    c_is_equal)
        if (c_is_equal==QTRUE) then
            is_equal = .true.
        else
            is_equal = .false.
        end if
    end function QcMatCfArray_f

    function QcMatGetAllValues_f(A,           &
                                 row_major,   &
                                 size_values, &
                                 values_real, &
                                 values_imag) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A
        logical(kind=4), intent(in) :: row_major
        integer(kind=QINT), intent(in) :: size_values
        real(kind=QREAL), intent(out) :: values_real(size_values)
        real(kind=QREAL), intent(out) :: values_imag(size_values)
        integer(kind=QINT) c_row_major
        if (row_major) then
            c_row_major = QTRUE
        else
            c_row_major = QFALSE
        end if
        ierr = f03_api_QcMatGetAllValues(A%c_mat,     &
                                         c_row_major, &
                                         size_values, &
                                         values_real, &
                                         values_imag)
    end function QcMatGetAllValues_f

    function QcMat_C_F_POINTER(A, c_A) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(inout) :: A(:)
        type(C_PTR), intent(in) :: c_A(:)
        integer(kind=QINT) imat
        ierr = QSUCCESS
        do imat = 1, size(A)
            if (c_associated(c_A(imat))) then
                A(imat)%c_mat = c_A(imat)
            else
#if defined(QCMATRIX_AUTO_ERROR_EXIT)
                call QErrorExit(6, __LINE__, "QcMat_C_F_POINTER")
#else
                ierr = QFAILURE
                return
#endif
            end if
        end do
    end function QcMat_C_F_POINTER

    function QcMat_C_NULL_PTR(A) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(inout) :: A(:)
        integer(kind=QINT) imat
        do imat = 1, size(A)
            if (c_associated(A(imat)%c_mat)) then
                A(imat)%c_mat = C_NULL_PTR
            end if
        end do
        ierr = QSUCCESS
    end function QcMat_C_NULL_PTR

    function QcMat_C_LOC(A, c_A) result(ierr)
        integer(kind=4) :: ierr
        type(QcMat), intent(in) :: A(:)
        type(C_PTR), intent(inout) :: c_A(:)
        integer(kind=QINT) imat
        ierr = QSUCCESS
        do imat = 1, size(A)
            if (c_associated(A(imat)%c_mat)) then
                c_A(imat) = A(imat)%c_mat
            else
#if defined(QCMATRIX_AUTO_ERROR_EXIT)
                call QErrorExit(6, __LINE__, "QcMat_C_LOC")
#else
                ierr = QFAILURE
                return
#endif
            end if
        end do
    end function QcMat_C_LOC

end module qcmatrix_f
